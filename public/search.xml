<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[CSAPP] 机器表示</title>
      <link href="/2020/10/06/csapp-pre-bomblab/"/>
      <url>/2020/10/06/csapp-pre-bomblab/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一些容易忘的…x86-64下…</p></blockquote><ul><li>寄存器：程序计数器PC(%rsp) + 整数寄存器(16*64bit) + 条件码寄存器 + 一组向量寄存器</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006162747.png" width="500px"> </div><p>生成1字节和2字节的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0</p><ul><li>寻址方式</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006164718.png" width="500px"> </div><ul><li>压栈和出栈指令</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006164337.png" width="500px"> </div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushq %rbp</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subq $8,%rsp;栈指针减</span><br><span class="line">movq %rbp,(%rsp);store</span><br></pre></td></tr></table></figure><ul><li><p>lea 加载有效地址</p><p>目的：将有效地址写入到目的操作数，<strong>根本就没有引用内存</strong></p><p>leaq 7(%rdx,%rdx,4),%rax  如%rdx为x，则将%rax设置为5x+7</p></li><li><p>过程</p><ul><li>传递控制：进入Q时，PC被设置为Q代码的起始地址，返回时，PC设置为P中调用Q后的指令</li><li>传递数据：P必须向Q提供一个或多个参数，Q必须能够向P返回一个值</li><li>分配和释放内存：开始时Q会分配局部空间，返回前必须释放这些空间</li></ul></li><li><p>运行时栈</p><ul><li>通过寄存器传参最多只能6个，超过6个需要P在自己的栈帧里存储好这些参数</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006170142.png" width="500px"> </div><ul><li><p>转移控制</p><ul><li><p>call Q</p><p>把返回地址压入栈，并把PC设为Q的起始地址</p></li><li><p>ret</p><p>会从栈中弹出地址A，并把PC设置为返回地址（call指令的下一条）</p></li></ul></li><li><p>数据传送</p></li></ul><p>x86-64中，可以通过寄存器最多传递6个整型参（例如整数和指针）参数。寄存器的使用是有特殊顺序的，名字取决于数据类型大小</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006171042.png" width="500px"> </div><p>如果参数大于6，则把参数7~n放到栈上，<strong>参数7位于栈顶</strong>。通过栈传递参数时，所有的数据大小都向8对齐</p><ul><li><p>栈上的局部存储</p><p>有时候，局部数据必须存放在内存里：</p><ul><li>寄存器不足够存放所有的本地数据</li><li>对一个局部变量使用地址运算符’&amp;’，因此必须能够为它产生一个地址</li><li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到</li></ul></li><li><p>寄存器中的局部存储空间</p><ul><li>被调用者保存寄存器：%rbx,%rbp和%r12~%r15 过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改了值，然后在返回之前从栈中弹出旧值</li><li>调用者保存寄存器：其他除了%rsp 过程Q可以随意修改这个寄存器，因为在调用之前保存是P的责任</li></ul></li><li><p>数据对齐</p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006214508.png" width="500px"> </div>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB commands Summary</title>
      <link href="/2020/10/06/GDB-summary/"/>
      <url>/2020/10/06/GDB-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="summary-of-gdb-commands-for-x86-64-systems"><a class="markdownIt-Anchor" href="#summary-of-gdb-commands-for-x86-64-systems"></a> Summary of GDB commands for x86-64 Systems</h2><p>做csapp的lab时偶然发现了这个，存一下…</p><p><a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.txt" target="_blank" rel="noopener">原文地址</a></p><h3 id="starting"><a class="markdownIt-Anchor" href="#starting"></a> Starting:</h3><table><thead><tr><th>Command</th></tr></thead><tbody><tr><td>gdb</td></tr><tr><td>gdb <file></td></tr></tbody></table><h3 id="running-and-stopping"><a class="markdownIt-Anchor" href="#running-and-stopping"></a> Running and stopping</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>quit</td><td>Exit gdb</td></tr><tr><td>run</td><td>Run program</td></tr><tr><td>run 1 2 3</td><td>Run program with command-line arguments 1 2 3</td></tr><tr><td>kill</td><td>Stop the program</td></tr><tr><td>quit</td><td>Exit gdb</td></tr><tr><td>Ctrl-d</td><td>Exit gdb</td></tr></tbody></table><p>Note: Ctrl-C does not exit from gdb, but halts the current gdb command</p><h3 id="breakpoints"><a class="markdownIt-Anchor" href="#breakpoints"></a> Breakpoints</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>break sum</td><td>Set breakpoint at the entry to function sum</td></tr><tr><td>break *0x80483c3</td><td>Set breakpoint at address 0x80483c3</td></tr><tr><td>delete 1</td><td>Delete breakpoint 1</td></tr><tr><td>disable 1</td><td>Disable the breakpoint 1 (gdb numbers each breakpoint you create)</td></tr><tr><td>enable 1</td><td>Enable breakpoint 1</td></tr><tr><td>delete</td><td>Delete all breakpoints</td></tr><tr><td>clear sum</td><td>Clear any breakpoints at the entry to function sum</td></tr></tbody></table><h3 id="execution"><a class="markdownIt-Anchor" href="#execution"></a> Execution</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>stepi</td><td>Execute one instruction</td></tr><tr><td>stepi 4</td><td>Execute four instructions</td></tr><tr><td>nexti</td><td>Like stepi, but proceed through function calls without stopping</td></tr><tr><td>step</td><td>Execute one C statement</td></tr><tr><td>continue</td><td>Resume execution until the next breakpoint</td></tr><tr><td>until 3</td><td>Continue executing until program hits breakpoint 3</td></tr><tr><td>finish</td><td>Resume execution until current function returns</td></tr><tr><td>call sum(1, 2)</td><td>Call sum(1,2) and print return value</td></tr></tbody></table><h3 id="examining-code"><a class="markdownIt-Anchor" href="#examining-code"></a> Examining code</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>disas</td><td>Disassemble current function</td></tr><tr><td>disas sum</td><td>Disassemble function sum</td></tr><tr><td>disas 0x80483b7</td><td>Disassemble function around 0x80483b7</td></tr><tr><td>disas 0x80483b7 0x80483c7</td><td>Disassemble code within specified address range</td></tr><tr><td></td><td></td></tr><tr><td>print /x $rip</td><td>Print program counter in hex</td></tr><tr><td>print /d $rip</td><td>Print program counter in decimal</td></tr><tr><td>print /t $rip</td><td>Print program counter in binary</td></tr></tbody></table><h2 id="examining-data"><a class="markdownIt-Anchor" href="#examining-data"></a> Examining data</h2><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>print /d $rax</td><td>Print contents of %rax in decimal</td></tr><tr><td>print /x $rax</td><td>Print contents of %rax in hex</td></tr><tr><td>print /t $rax</td><td>Print contents of %rax in binary</td></tr><tr><td>print /d (int)$rax</td><td>Print contents of %rax in decimal after sign-extending lower 32-bits.</td></tr></tbody></table><p>You need this to print 32-bit, negative numbers stored in the lower 32 bits of %rax. For example, if the lower 32-bits of %rax store 0xffffffff, you will see</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span> <span class="variable">$rax</span></span><br><span class="line"><span class="variable">$1</span> = 4294967295</span><br><span class="line">(gdb) <span class="built_in">print</span> (int)<span class="variable">$rax</span></span><br><span class="line"><span class="variable">$2</span> = -1</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>print 0x100</td><td>Print decimal representation of 0x100</td></tr><tr><td>print /x 555</td><td>Print hex representation of 555</td></tr><tr><td>print /x ($rsp+8)</td><td>Print (contents of %rsp) + 8 in hex</td></tr><tr><td>print *(int *) 0xbffff890</td><td>Print integer at address 0xbffff890</td></tr><tr><td>print *(int *) ($rsp+8)</td><td>Print integer at address %rsp + 8</td></tr><tr><td>print (char *) 0xbfff890</td><td>Examine a string stored at 0xbffff890</td></tr><tr><td></td><td></td></tr><tr><td>x/w   0xbffff890</td><td>Examine (4-byte) word starting at address 0xbffff890</td></tr><tr><td>x/w   $rsp</td><td>Examine (4-byte) word starting at address in $rsp</td></tr><tr><td>x/wd  $rsp</td><td>Examine (4-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td>x/2w  $rsp</td><td>Examine two (4-byte) words starting at address in $rsp</td></tr><tr><td>x/2wd $rsp</td><td>Examine two (4-byte) words starting at address in $rsp. Print in decimal</td></tr><tr><td>x/g   $rsp</td><td>Examine (8-byte) word starting at address in $rsp.</td></tr><tr><td>x/gd  $rsp</td><td>Examine (8-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td>x/a   $rsp</td><td>Examine address in $rsp. Print as offset from previous global symbol.</td></tr><tr><td>x/s   0xbffff890</td><td>Examine a string stored at 0xbffff890</td></tr><tr><td>x/20b sum</td><td>Examine first 20 opcode bytes of function sum</td></tr><tr><td>x/10i sum</td><td>Examine first 10 instructions of function sum</td></tr></tbody></table><p>Note: the format string for the ‘x’ command has the general form x/[NUM][SIZE][FORMAT] where</p><blockquote><p>NUM  = number of objects to display<br />SIZE = size of each object (b=byte, h=half-word, w=word, g=giant (quad-word))<br />FORMAT = how to display each object (d=decimal, x=hex, o=octal, etc.)</p></blockquote><p>If you don’t specify SIZE or FORMAT, either a default value, or the last value you specified in a previous ‘print’ or ‘x’ command is used.</p><h3 id="useful-information"><a class="markdownIt-Anchor" href="#useful-information"></a> Useful information</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>backtrace</td><td>Print the current address and stack backtrace</td></tr><tr><td>where</td><td>Print the current address and stack backtrace</td></tr><tr><td></td><td></td></tr><tr><td>info program</td><td>Print current status of the program)</td></tr><tr><td>info functions</td><td>Print functions in program</td></tr><tr><td>info stack</td><td>Print backtrace of the stack)</td></tr><tr><td>info frame</td><td>Print information about the current stack frame</td></tr><tr><td>info registers</td><td>Print registers and their contents</td></tr><tr><td>info breakpoints</td><td>Print status of user-settable breakpoints</td></tr><tr><td></td><td></td></tr><tr><td>display /FMT EXPR</td><td>Print expression EXPR using format FMT every time GDB stops</td></tr><tr><td>undisplay</td><td>Turn off display mode</td></tr><tr><td>help</td><td>Get information about gdb</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Labs </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS143 编译原理-3</title>
      <link href="/2020/10/06/cs143-3/"/>
      <url>/2020/10/06/cs143-3/</url>
      
        <content type="html"><![CDATA[<h2 id="语法分析2"><a class="markdownIt-Anchor" href="#语法分析2"></a> 语法分析2</h2><h3 id="first集"><a class="markdownIt-Anchor" href="#first集"></a> First集</h3><h4 id="如何构建parsing-table-构建ll1parsing-table需要哪些条件"><a class="markdownIt-Anchor" href="#如何构建parsing-table-构建ll1parsing-table需要哪些条件"></a> 如何构建parsing table 构建LL(1)parsing table需要哪些条件</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003132022.png" width="600px"> </div><p>[上图解释]</p><p>给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>α</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">A, \alpha, t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span></span></span></span> 在什么情况下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">T[A, t]=\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>能成立？</p><p>第一种情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>通过一步或多步推导能推出t，且t处在第一个位置，这时候说t属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的First集；</p><p>第二种情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>不能直接推出t（t不属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的First集），但A能推出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>能推出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>，且在某个产生式中t位置在A后，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">T[A, t]=\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>也能成立，且称t属于A的Follow集</p><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003135005.png" width="300px"> </div><p>一些可推规则：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003135447.png" width="500px"> </div><p>求First集的一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003140150.png" width="500px"> </div><h3 id="follow集"><a class="markdownIt-Anchor" href="#follow集"></a> Follow集</h3><h4 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003162550.png" width="300px"> </div><p>一些可推规则：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003163011.png" width="400px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003163151.png" width="400px"> </div><p>求First集的一个例子，需要用到First集：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003164657.png" width="600px"> </div><h3 id="ll1-pasring-tables"><a class="markdownIt-Anchor" href="#ll1-pasring-tables"></a> LL(1) Pasring Tables</h3><p>使用First集和Follow集来构建LL(1) parsing table</p><p>目的：对于CFG G，构建一个parsing table T</p><p>对每一个在G中的产生式进行以下算法：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003170101.png" width="400px"> </div><p>考虑每个生成式在右侧第一个位置能生成什么</p><p>一个生成LL(1) parsing table 的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003170958.png" width="550px"> </div><p>如果走到了表格中的空白区域则说明解析错误</p><p>如果对一个左递归的grammar构建parsing table：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">S\rightarrow Sa|b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord mathdefault">b</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003171506.png" width="400px"> </div><p>构建出来的parsing table中的某些单元格中可能存在多种选择，则这个语法不是LL(1)的</p><p>[not left factored] [left recursive] [ambiguous] [other] 都不是LL(1)的，实际上大多数编程语言的CFG都不是LL(1)的，LL(1)语法太弱</p><h3 id="自下而上的解析-bottom-up-parsing"><a class="markdownIt-Anchor" href="#自下而上的解析-bottom-up-parsing"></a> 自下而上的解析 Bottom-Up Parsing</h3><p>自下而上解析比自上而下解析更加通用，且也高效，用到了自上而下的思想，是大多数编译器首选的方法</p><ul><li>自下而上解析不需要left-factored语法</li></ul><p>一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201004104247.png" width="500px"> </div><p><strong>reduce 规约</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CSAPP] Bomb Lab</title>
      <link href="/2020/10/06/csapp-bomblab/"/>
      <url>/2020/10/06/csapp-bomblab/</url>
      
        <content type="html"><![CDATA[<h2 id="bomb-lab"><a class="markdownIt-Anchor" href="#bomb-lab"></a> Bomb Lab</h2><p>传说中的bomb lab，我开始以为这名字意思是更改了程序汇编代码，让你修复…直到看了writeup…</p><p>一些预备知识，主要为<a href="https://wfc.ink/2020/10/06/csapp-pre-bomblab/">CSAPP第三方</a></p><blockquote><p>题目大致意思就是不给源码（但给了源码框架），然你通过各种工具（gdb，objdump）调试，获取6次正确的输入。输入错误字符串会BOOMMMM !</p></blockquote><p>部分源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">initialize_bomb();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"which to blow yourself up. Have a nice day!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">                                  * Let me know how they did it. */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Phase 1 defused. How about the next one?\n"</span>);</span><br></pre></td></tr></table></figure><h3 id="phase_1"><a class="markdownIt-Anchor" href="#phase_1"></a> phase_1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$objdump</span> -d bomb &gt; log.txt</span><br></pre></td></tr></table></figure><p>main函数中调用phase_1的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400e32:       e8 67 06 00 00          callq  40149e &lt;read_line&gt;;读入一串字符，地址存在%rax</span><br><span class="line">400e37:       48 89 c7                mov    %rax,%rdi;%mov到%rdi</span><br><span class="line">400e3a:       e8 a1 00 00 00          callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:       e8 80 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure><p>phase_1的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400ee4:       be 00 24 40 00          mov    $0x402400,%esi;字符常量地址存入%esi</span><br><span class="line">  400ee9:       e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:       85 c0                   test   %eax,%eax;判断返回值是否为0</span><br><span class="line">  400ef0:       74 05                   je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:       e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400efb:       c3                      retq</span><br></pre></td></tr></table></figure><p>strings_not_equal的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;:</span><br><span class="line">  401338:       41 54                   push   %r12</span><br><span class="line">  40133a:       55                      push   %rbp</span><br><span class="line">  40133b:       53                      push   %rbx</span><br><span class="line">  40133c:       48 89 fb                mov    %rdi,%rbx;读入字符串地址</span><br><span class="line">  40133f:       48 89 f5                mov    %rsi,%rbp;字符常量地址</span><br><span class="line">  401342:       e8 d4 ff ff ff          callq  40131b &lt;string_length&gt;</span><br><span class="line">  401347:       41 89 c4                mov    %eax,%r12d;求长度结果</span><br><span class="line">  40134a:       48 89 ef                mov    %rbp,%rdi</span><br><span class="line">  40134d:       e8 c9 ff ff ff          callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:       ba 01 00 00 00          mov    $0x1,%edx;求长度结果</span><br><span class="line">  401357:       41 39 c4                cmp    %eax,%r12d;比较长度，如不等长直接返回</span><br><span class="line">  40135a:       75 3f                   jne    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40135c:       0f b6 03                movzbl (%rbx),%eax</span><br><span class="line">  40135f:       84 c0                   test   %al,%al</span><br><span class="line">  401361:       74 25                   je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:       3a 45 00                cmp    0x0(%rbp),%al</span><br><span class="line">  401366:       74 0a                   je     401372 &lt;strings_not_equal+0x3a&gt;</span><br><span class="line">  401368:       eb 25                   jmp    40138f &lt;strings_not_equal+0x57&gt;</span><br><span class="line">  40136a:       3a 45 00                cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:       0f 1f 00                nopl   (%rax)</span><br><span class="line">  401370:       75 24                   jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:       48 83 c3 01             add    $0x1,%rbx;双字符串指针都+1判断是否相等</span><br><span class="line">  401376:       48 83 c5 01             add    $0x1,%rbp</span><br><span class="line">  40137a:       0f b6 03                movzbl (%rbx),%eax</span><br><span class="line">  40137d:       84 c0                   test   %al,%al</span><br><span class="line">  40137f:       75 e9                   jne    40136a &lt;strings_not_equal+0x32&gt;</span><br><span class="line">  401381:       ba 00 00 00 00          mov    $0x0,%edx</span><br><span class="line">  401386:       eb 13                   jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:       ba 00 00 00 00          mov    $0x0,%edx</span><br><span class="line">  40138d:       eb 0c                   jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:       ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">  401394:       eb 05                   jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:       ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">  40139b:       89 d0                   mov    %edx,%eax</span><br><span class="line">  40139d:       5b                      pop    %rbx</span><br><span class="line">  40139e:       5d                      pop    %rbp</span><br><span class="line">  40139f:       41 5c                   pop    %r12</span><br><span class="line">  4013a1:       c3                      retq</span><br></pre></td></tr></table></figure><p>string_length的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040131b &lt;string_length&gt;:</span><br><span class="line">  40131b:       80 3f 00                cmpb   $0x0,(%rdi);指针判空，空指针直接返回0</span><br><span class="line">  40131e:       74 12                   je     401332 &lt;string_length+0x17&gt;</span><br><span class="line">  401320:       48 89 fa                mov    %rdi,%rdx</span><br><span class="line">  401323:       48 83 c2 01             add    $0x1,%rdx;每次地址+1，循环检测&#39;\0&#39;</span><br><span class="line">  401327:       89 d0                   mov    %edx,%eax</span><br><span class="line">  401329:       29 f8                   sub    %edi,%eax;返回的长度</span><br><span class="line">  40132b:       80 3a 00                cmpb   $0x0,(%rdx)</span><br><span class="line">  40132e:       75 f3                   jne    401323 &lt;string_length+0x8&gt;</span><br><span class="line">  401330:       f3 c3                   repz retq</span><br><span class="line">  401332:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401337:       c3                      retq</span><br></pre></td></tr></table></figure><p>phase_1挺简单，就判断输入的字符串和给定的字符串常量是否相等，不相同则boom。输入的字符串起始地址为%rdi，给定的字符串起始地址为%esi，调用strings_not_equal判断是否相同。strings_not_equal首先调用string_length求字符串长度，不相同则直接返回，string_length就使用每次指针+1，检测所指内存区域是否为’\0’的方式求长度。如长度相等则再依次对比每个字符，不相等则直接返回。</p><p>所以，需要输入的字符串就是给定的字符串常量，位于内存0x402400，使用gdb打印出内存信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gdb ./bomb</span><br><span class="line">(gdb) b phase_1</span><br><span class="line">Breakpoint 1 at 0x400ee0</span><br><span class="line">(gdb) r</span><br><span class="line">[随意的错误输入]</span><br><span class="line">Breakpoint 1, 0x0000000000400ee0 <span class="keyword">in</span> phase_1 ()</span><br><span class="line">(gdb) <span class="built_in">print</span> (char*) 0x402400</span><br><span class="line"><span class="variable">$1</span> = 0x402400 <span class="string">"Border relations with Canada have never been better."</span></span><br></pre></td></tr></table></figure><p>答案是 Border relations with Canada have never been better.</p><h3 id="phase_2"><a class="markdownIt-Anchor" href="#phase_2"></a> phase_2</h3><p>phase_2的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:       55                      push   %rbp</span><br><span class="line">  400efd:       53                      push   %rbx</span><br><span class="line">  400efe:       48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:       48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  400f05:       e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:       83 3c 24 01             cmpl   $0x1,(%rsp);和1比较</span><br><span class="line">  400f0e:       74 20                   je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:       e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:       eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:       8b 43 fc                mov    -0x4(%rbx),%eax;前一个单元的值</span><br><span class="line">  400f1a:       01 c0                   add    %eax,%eax;前一个单元的值*2</span><br><span class="line">  400f1c:       39 03                   cmp    %eax,(%rbx);前一个单元的值*2和当前单元比较</span><br><span class="line">  400f1e:       74 05                   je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:       e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:       48 83 c3 04             add    $0x4,%rbx</span><br><span class="line">  400f29:       48 39 eb                cmp    %rbp,%rbx</span><br><span class="line">  400f2c:       75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:       eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:       48 8d 5c 24 04          lea    0x4(%rsp),%rbx;将%rsp所指单元的上一个单元地址传%rbx</span><br><span class="line">  400f35:       48 8d 6c 24 18          lea    0x18(%rsp),%rbp;将%rsp+24所指单元的地址传%rbx，作为循环结束条件</span><br><span class="line">  400f3a:       eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:       48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:       5b                      pop    %rbx</span><br><span class="line">  400f41:       5d                      pop    %rbp</span><br><span class="line">  400f42:       c3                      retq</span><br></pre></td></tr></table></figure><p>read_six_numbers的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:       48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  401460:       48 89 f2                mov    %rsi,%rdx;存的就是phase_2栈帧底部的地址</span><br><span class="line">  401463:       48 8d 4e 04             lea    0x4(%rsi),%rcx;传地址参数到寄存器</span><br><span class="line">  401467:       48 8d 46 14             lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:       48 89 44 24 08          mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:       48 8d 46 10             lea    0x10(%rsi),%rax</span><br><span class="line">  401474:       48 89 04 24             mov    %rax,(%rsp)</span><br><span class="line">  401478:       4c 8d 4e 0c             lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:       4c 8d 46 08             lea    0x8(%rsi),%r8</span><br><span class="line">  401480:       be c3 25 40 00          mov    $0x4025c3,%esi</span><br><span class="line">  401485:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  40148a:       e8 61 f7 ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:       83 f8 05                cmp    $0x5,%eax;返回值：读取到的数量</span><br><span class="line">  401492:       7f 05                   jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:       e8 a1 ff ff ff          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:       48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  40149d:       c3                      retq</span><br></pre></td></tr></table></figure><p>phase_2主要是个循环，read_six_number将phase_2栈帧地址较低处6个int型内存单元的地址传给__isoc99_sscanf@plt，sscanff读取6个数到phase_2栈帧底部的6个单元，并返回读取到的int数量，存到%eax，如果数量小于6，则boom。</p><p>在phase_2的汇编代码中，首先将phase_2栈帧的最低地址单元与常数1相比，如果不等则boom，如果相等，则进行循环：用%rbx记录当前所指单元，将前一个单元的值的两倍和当前单元比较（第一个单元值为1），不相等则boom。当%rbx和%rbp相等时，循环结束。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201007112329.png" width="250px"> </div><h3 id="phase_3"><a class="markdownIt-Anchor" href="#phase_3"></a> phase_3</h3>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Labs </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CSAPP] Data Lab</title>
      <link href="/2020/10/05/csapp-datalab/"/>
      <url>/2020/10/05/csapp-datalab/</url>
      
        <content type="html"><![CDATA[<h2 id="data-lab"><a class="markdownIt-Anchor" href="#data-lab"></a> Data Lab</h2><p>【踩的坑】在centos7下进行的实验，缺32位glibc, gcc库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[wangfangcao@wfcserver datalab-handout]$ make</span><br><span class="line">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c</span><br><span class="line">In file included from /usr/include/features.h:399:0,</span><br><span class="line">                 from /usr/include/stdio.h:27,</span><br><span class="line">                 from btest.c:16:</span><br><span class="line">/usr/include/gnu/stubs.h:7:27: fatal error: gnu/stubs-32.h: No such file or directory</span><br><span class="line"> <span class="comment"># include &lt;gnu/stubs-32.h&gt;</span></span><br><span class="line">                           ^</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>解决办法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install glibc-devel.i686</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[wangfangcao@wfcserver datalab-handout]$ make</span><br><span class="line">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/libgcc_s.so when searching <span class="keyword">for</span> -lgcc_s</span><br><span class="line">/usr/bin/ld: cannot find -lgcc_s</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make: *** [btest] Error 1</span><br></pre></td></tr></table></figure><p>解决办法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y libgcc.i686</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Labs </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS143 编译原理-2</title>
      <link href="/2020/10/03/cs143-2/"/>
      <url>/2020/10/03/cs143-2/</url>
      
        <content type="html"><![CDATA[<h2 id="语法分析1"><a class="markdownIt-Anchor" href="#语法分析1"></a> 语法分析1</h2><p>有些语法（比如<strong>括号嵌套匹配</strong>无法使用正则表达式来表示）</p><p><strong>Paring</strong>:</p><ul><li><strong>Input</strong>: sequence of tokens from lexer （token序列）</li><li><strong>Output</strong>: parse tree of the program （语法树）</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928225221.png" width="500px"> </div> <h3 id="上下文无关文法-context-free-grammers-cfgs"><a class="markdownIt-Anchor" href="#上下文无关文法-context-free-grammers-cfgs"></a> 上下文无关文法 (Context-Free Grammers CFGs)</h3><ul><li><p>不是所有的strings都是合法的程序，所以需要Language来描述有效的strings，需要一个方法来区分有效和无效的strings</p></li><li><p>编程语言通常具有递归形式，CFGs可以是递归结构的一种自然标记</p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928225954.png" width="350px"> </div><p>终结符T 非终结符N 一个产生式集合</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928235823.png" width="400px"> </div><p>从一个符号S开始，不断用产生式替换右边，直到右边没有非终结符为止</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929000352.png" width="400px"> </div><p>一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929000519.png" width="400px"> </div><p>CFG的目标：</p><ol><li>输出&quot;yes&quot; or “no”；并且输出语法树</li><li>处理error</li><li>CFG的实现（e.g., bison）</li></ol><h3 id="推导"><a class="markdownIt-Anchor" href="#推导"></a> 推导</h3><ul><li>Grammar <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>→</mo><mi>E</mi><mo>+</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mo>∗</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">E\rightarrow E+E|E*E|(E)|id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></li><li>String <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi><mo>∗</mo><mi>i</mi><mi>d</mi><mo>+</mo><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id*id+id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929203505.png" width="500px"> </div><p>这个例子的是left-most derivation，在每一步替换最左的non-terminal</p><p>right-most 和 left-most derivations 形成相同的parse tree</p><p><strong>A parse tree has</strong>:</p><ol><li>Terminals at the leaves</li><li>Non-terminals at the interior nodes</li></ol><p>一个derivation定义了一颗parse tree</p><h3 id="二义性-ambiguity"><a class="markdownIt-Anchor" href="#二义性-ambiguity"></a> 二义性 Ambiguity</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929205102.png" width="500px"> </div><p>一个grammer是ambiguity的如果有超过一颗parse tree</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201001113537.png" width="500px"> </div><p>解决ambiguity的方法是重写grammer，改变优先级；或者可以通过定义优先级</p><h3 id="error-handing"><a class="markdownIt-Anchor" href="#error-handing"></a> Error Handing</h3><ul><li>Panic mode</li><li>Error productions</li><li>Automatic local or global correction</li></ul><h3 id="ast-抽象语法树"><a class="markdownIt-Anchor" href="#ast-抽象语法树"></a> AST 抽象语法树</h3><p>像parse trees但是忽略了一些细节</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002144333.png" width="300px"> </div><ul><li><p>从具体的语义抽象 =&gt; 更加紧凑 &amp; 简单</p></li><li><p>编译器中重要的数据结构</p></li></ul><h3 id="递归下降解析-recursive-descent-parsing"><a class="markdownIt-Anchor" href="#递归下降解析-recursive-descent-parsing"></a> 递归下降解析 Recursive Descent Parsing</h3><p>(第一个parsing算法)</p><p>一个top-down parsing算法</p><ul><li>The parse tree is constructed<ul><li>From the top</li><li>From left to right</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002152907.png" width="500px"> </div><h4 id="递归下降算法的一般描述"><a class="markdownIt-Anchor" href="#递归下降算法的一般描述"></a> 递归下降算法的一般描述</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002200003.png" width="400px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002200134.png" width="400px"> </div><ul><li><p>check TOKEN和当前输入流中所指的对象是否相等</p></li><li><p>检查和S的某一个产生式是否匹配</p></li><li><p>检查和S的任何产生式是否匹配</p></li></ul><p>一个编码的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002201258.png" width="400px"> </div><p>(PLUS: ’ + ')</p><ul><li>save保存初始指针</li><li>第一个产生式返回false则尝试第二个</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002201618.png" width="500px"> </div><h4 id="limitations-递归下降的局限性"><a class="markdownIt-Anchor" href="#limitations-递归下降的局限性"></a> Limitations 递归下降的局限性</h4><p>一旦找到一个能够用在非终结符元素的产生式的话，那么就没有回滚操作</p><ul><li>If a production for non-terminal X succeeds<ul><li>Cannot backtrack to try a different production for X later</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002204605.png" width="800px"> </div><ul><li>这边所讲的递归下降并不通用，但是容易实现</li><li>通过提取左因子 left factoring，可以对这个算法进行rewrite</li></ul><h3 id="左递归-left-recursion"><a class="markdownIt-Anchor" href="#左递归-left-recursion"></a> 左递归 Left Recursion</h3><p>递归下降算法中的主要难点</p><p>左递归的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002205539.png" width="300px"> </div><p><strong>Left Recursion 左递归</strong>:</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002205631.png" width="500px"> </div><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mi>a</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi>a</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi>a</mi><mi>a</mi><mo>…</mo></mrow><annotation encoding="application/x-tex">S\rightarrow Sa \rightarrow Saa \rightarrow Saaa \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span></p><p><strong>递归下降算法</strong>不适用于<strong>左递归</strong>情形</p><p>左递归语法的一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002210207.png" width="500px"> </div><p>主要原因是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>是最后的推导产生的，却在第一个位置，这不符合从左到右解析的原则</p><p><strong>可以使用右递归语法 right-recursion 进行重写</strong></p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002210454.png" width="500px"> </div><p><em>Dragon Book</em>中有消除左递归的具体算法</p><p>小结：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002211241.png" width="350px"> </div><p>一般编译器中都会采取手写praser的做法，如gcc</p><h3 id="预测解析-predictive-parsing"><a class="markdownIt-Anchor" href="#预测解析-predictive-parsing"></a> 预测解析 Predictive Parsing</h3><ul><li><p>类似递归下降，但是praser能预测使用哪个产生式</p><ul><li>looking at the next few tokens</li><li>不回滚</li></ul></li><li><p>预测praser能接受LL(k)语法 (left-to-right, left-most derivation, look forward k tokens)</p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003003010.png" width="350px"> </div><p>在递归下降算法中，每一步都有许多产生式选择，如果选择错了就回滚</p><p>在LL(1)中，每一步都只有一种选择</p><h4 id="we-need-to-left-factor-the-grammar-提取左公因子"><a class="markdownIt-Anchor" href="#we-need-to-left-factor-the-grammar-提取左公因子"></a> We need to left-factor the grammar 提取左公因子</h4><p><strong>目的</strong>：消除一个非终结符的多个产生式的公共前缀</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003111250.png" width="250px"> </div><p>通过提取左公因式，可以将产生式的执行推迟进行，先prase公共的非终结符</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113332.png" width="500px"> </div><p>通过grammar生成parsing table</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113423.png" width="500px"> </div><ul><li><p>方法与递归下降类似，除了</p><ul><li>对于最左的非终结符S</li><li>look at下一个token</li><li>在表中找到对应的产生式</li></ul></li><li><p>用一个栈来存放之前的parse tree，栈顶是当前要parse的非终结符或者终结符</p></li></ul><p>算法：</p><p>($符号表示end of input)</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113459.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113532.png" width="500px"> </div>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS143 编译原理-1</title>
      <link href="/2020/09/28/cs143-1/"/>
      <url>/2020/09/28/cs143-1/</url>
      
        <content type="html"><![CDATA[<ul><li>编译器结构<ol><li>词法分析 (Lexical Analysis)</li><li>语法分析 (Parsing)</li><li>语义分析 (Semantic Analysis)</li><li>优化 (Optimization)</li><li>代码生成 (Code Generation)</li></ol></li></ul><p>早期的编译器和现在的编译器的对比：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927155639.png" width="500px"> </div><p>现在的编译器花了更多的时间在优化上面</p><h2 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h2><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927160531.png" width="500px"> </div><p>“Words” =&gt; “Tokens Class”: <strong>Identifier</strong>, <strong>keywords</strong>, ‘<strong>(</strong>’, ‘<strong>)</strong>’, <strong>numbers</strong>, …</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927160906.png" width="500px"> </div><p>词法分析器将字符子串分类成Tokens，传递给<strong>Parser</strong></p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927161438.png" width="500px"> </div><ul><li>Left-to-right scan =&gt; lookahead sometimes required 有时候需要向前几个字符参考，来确定当前的token</li></ul><h3 id="正则语言-regular-languages"><a class="markdownIt-Anchor" href="#正则语言-regular-languages"></a> 正则语言 Regular Languages</h3><ul><li>Regular expressions</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927164524.png" width="280px"> </div><p><strong>Epsilon</strong>不是空集，是一个只包含空字符的集合</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927164758.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927165627.png" width="500px"> </div><p>grammar: 文法</p><ul><li>Regular expressions (syntax) specify regular languages (set of strings)</li></ul><h3 id="形式化语言-formal-languages"><a class="markdownIt-Anchor" href="#形式化语言-formal-languages"></a> 形式化语言 Formal Languages</h3><ul><li><p><strong>Def.</strong> Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> be a set of characters (an alphabet).</p><p>A <strong>language</strong> over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> is a set of strings of characters drawn from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span></p></li><li><p>Meaning function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> maps <strong>syntax</strong> to <strong>semantics</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>:</mo><mi>E</mi><mi>x</mi><mi>p</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>s</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">L: Exp\rightarrow Sets\ of\ Strings</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">s</span></span></span></span></p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927172527.png" width="500px"> </div><ul><li>Meaning is many to one<ul><li>Never one to many!</li></ul></li></ul><h3 id="lexical-specifications"><a class="markdownIt-Anchor" href="#lexical-specifications"></a> Lexical Specifications</h3><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msup><mi>A</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">AA^*=A^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232010.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232447.png" width="500px"> </div><p>最后一个表示补集</p><ul><li>如何预测一个s是不是属于L®</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232857.png" width="500px"> </div><p>写出所有类型token的正则表达式</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232923.png" width="500px"> </div><p>构建R，R能匹配所有类型的token</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927234514.png" width="500px"> </div><p>检查前缀是不是属于R，如果属于R，则一定属于R中的某个token类Rj，删除匹配完成的前缀接着进行第三步</p><p><strong>一些问题</strong>：</p><ol><li><p>当较短和较长的字符串都匹配时，选较长的  “Maximal Match”</p></li><li><p>当同一个字符串和多个正则表达式匹配时，根据优先级</p></li><li><p>What if no rule matches? 添加一个错误类，优先级设置成最低</p></li></ol><h3 id="有限自动机"><a class="markdownIt-Anchor" href="#有限自动机"></a> 有限自动机</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928001815.png" width="450px"> </div><p>有限自动机是一种算法的实现</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928002027.png" width="450px"> </div><ul><li>在一个状态，读取一些输入，变成另一个状态</li><li>如果读完输入，最后处于接受状态，则accept，否则就reject</li></ul><h4 id="dfa-deterministic-finite-automata-确定的有限状态自动机"><a class="markdownIt-Anchor" href="#dfa-deterministic-finite-automata-确定的有限状态自动机"></a> DFA (Deterministic Finite Automata) 确定的有限状态自动机</h4><ul><li>对于一个input，只能有一个转换</li><li>NO <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>-moves</li><li>执行更快，因为每一步都没有选择</li></ul><h4 id="nfa-nondeterministic-finite-automata-不确定的优先状态自动机"><a class="markdownIt-Anchor" href="#nfa-nondeterministic-finite-automata-不确定的优先状态自动机"></a> NFA (Nondeterministic Finite Automata) 不确定的优先状态自动机</h4><ul><li>对于一个input，可以有多个转换</li><li>have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>-moves</li><li>smaller</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928153706.png" width="250px"> </div><h3 id="正则表达式-nfas"><a class="markdownIt-Anchor" href="#正则表达式-nfas"></a> 正则表达式 =&gt; NFAs</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161156.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928154159.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928154222.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160059.png" width="500px"> </div><p>一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160203.png" width="500px"> </div><h3 id="nfa-to-dfa"><a class="markdownIt-Anchor" href="#nfa-to-dfa"></a> NFA to DFA</h3><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi><mo>−</mo><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\epsilon -closure</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160434.png" width="500px"> </div><p>相应的<strong>DFA</strong>：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161008.png" width="500px"> </div><h3 id="implementing-finite-automata"><a class="markdownIt-Anchor" href="#implementing-finite-automata"></a> Implementing Finite Automata</h3><p>DFA可以用一张二维的表来表示：</p><ol><li>一维是states</li><li>一维是输入符号</li><li>表中是转换的下一个states</li></ol><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161404.png" width="250px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161500.png" width="500px"> </div><p>一种更加节省空间的做法：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161534.png" width="500px"> </div><p>NFA直接转换成table：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161835.png" width="500px"> </div><p>节省空间，但是这样比NFA=&gt;DFA=&gt;table慢</p>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构-1</title>
      <link href="/2020/04/30/redis-data-structure-1/"/>
      <url>/2020/04/30/redis-data-structure-1/</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串sds"><a class="markdownIt-Anchor" href="#简单动态字符串sds"></a> 简单动态字符串sds</h2><p>sds 的源码主要在 sds.h 和 sds.c 中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 buf 数组是柔性数组，在分配的时候不占内存大小</p><p>sds.h 中还有两个 inline 的静态函数，用于返回实际保存的字符串长度和可用空间的字符串长度</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span> <span class="comment">//buf地址往回sizeof(struct sdshdr))</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 可用空间的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边用了一个骚操作，用 buf 的数组指针减去8字节，就得到了结构体的初始位置，也就是结构体的指针：</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/redis/20200502162607.png" height="180px"></div>这个技巧在 redis 中多处用到<p>sds 主要接口函数声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 sds T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定字符串 init ，创建一个包含同样字符串的 sds T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个只保存了空字符串 "" 的 sds T = O(1)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sds 实际保存的字符串的长度 T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制给定 sds 的副本 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放给定的 sds T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sds 可用空间的长度 T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 sds 扩充至指定长度，未使用的空间以 0 字节填充 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定字符串 t 追加到 sds 的末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将另一个 sds 追加到一个 sds 的末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串 t 的前 len 个字符复制到 sds s 当中，并在字符串的最后添加终结符 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串复制到 sds 当中，覆盖原有的字符 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;</span><br></pre></td></tr></table></figure><p>其中几个：</p><ul><li><strong>sdsnew</strong><br />根据给定字符串 init ，创建一个包含同样字符串的 sds</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用了：</p><ul><li><strong>sdsnewlen</strong><br />根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>); <span class="comment">// 结构体+buf数组+'\0'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 zmalloc 和 zcalloc 为 redis 使用的内存管理工具，在 zmalloc.c 和 zmalloc.h 中定义</p><h2 id="双端链表"><a class="markdownIt-Anchor" href="#双端链表"></a> 双端链表</h2><p>双端链表 的源码主要在 adlist.h 和 adlist.c 中</p><p>双端链表节点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>双端链表结构:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>为了规范化的宏定义函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回给定链表所包含的节点数量</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表头节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表尾节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="comment">// 返回给定节点的前置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="comment">// 返回给定节点的后置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="comment">// 返回给定节点的值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表 l 的值复制函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="comment">// 将链表 l 的值释放函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="comment">// 将链表的对比函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的值复制函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值释放函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值对比函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure><p>几个主要接口函数：</p><ul><li><strong>listCreate</strong><br />创建一个新的链表 T = O(1)</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listRelease</strong><br />释放整个链表，以及链表中所有节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向头指针</span></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// 遍历整个链表</span></span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放节点结构</span></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表结构</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listAddNodeHead</strong><br />将一个包含有给定值指针 value 的新节点添加到链表的表头</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值指针</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点到空链表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 添加节点到非空链表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 redis 双端队列中使用了迭代器这一技巧</p><p>双端链表迭代器：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前迭代到的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代的方向</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line"></span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure><ul><li><strong>listGetIterator</strong><br />为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为迭代器分配内存</span></span><br><span class="line">    listIter *iter;</span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录迭代方向</span></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listNext</strong><br />返回迭代器当前所指向的节点<br />这个函数其实有两个作用：返回当前迭代器指向的节点 + 使迭代器指向下一个节点（我刚开始还没明白只return了一个current，怎么把iter传出去，后来看了这个函数的使用才知道，因为函数传入的是指针，只要定义一个listIter类型的指针，一直使用该函数就能迭代了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据方向选择下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listDup</strong><br />复制整个链表<br />其中就使用了上述的listNext来进行迭代</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新链表</span></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置节点值处理函数</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代整个输入链表</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制节点值到新节点</span></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将节点添加到链表</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回副本</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
