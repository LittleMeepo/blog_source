<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS143 编译原理-2</title>
      <link href="/2020/10/03/cs143-2/"/>
      <url>/2020/10/03/cs143-2/</url>
      
        <content type="html"><![CDATA[<h2 id="语法分析1"><a class="markdownIt-Anchor" href="#语法分析1"></a> 语法分析1</h2><p>有些语法（比如<strong>括号嵌套匹配</strong>无法使用正则表达式来表示）</p><p><strong>Paring</strong>:</p><ul><li><strong>Input</strong>: sequence of tokens from lexer （token序列）</li><li><strong>Output</strong>: parse tree of the program （语法树）</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928225221.png" width="500px"> </div> <h3 id="上下文无关文法-context-free-grammers-cfgs"><a class="markdownIt-Anchor" href="#上下文无关文法-context-free-grammers-cfgs"></a> 上下文无关文法 (Context-Free Grammers CFGs)</h3><ul><li><p>不是所有的strings都是合法的程序，所以需要Language来描述有效的strings，需要一个方法来区分有效和无效的strings</p></li><li><p>编程语言通常具有递归形式，CFGs可以是递归结构的一种自然标记</p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928225954.png" width="350px"> </div><p>终结符T 非终结符N 一个产生式集合</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928235823.png" width="400px"> </div><p>从一个符号S开始，不断用产生式替换右边，直到右边没有非终结符为止</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929000352.png" width="400px"> </div><p>一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929000519.png" width="400px"> </div><p>CFG的目标：</p><ol><li>输出&quot;yes&quot; or “no”；并且输出语法树</li><li>处理error</li><li>CFG的实现（e.g., bison）</li></ol><h3 id="推导"><a class="markdownIt-Anchor" href="#推导"></a> 推导</h3><ul><li>Grammar <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>→</mo><mi>E</mi><mo>+</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mo>∗</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">E\rightarrow E+E|E*E|(E)|id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></li><li>String <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi><mo>∗</mo><mi>i</mi><mi>d</mi><mo>+</mo><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id*id+id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929203505.png" width="500px"> </div><p>这个例子的是left-most derivation，在每一步替换最左的non-terminal</p><p>right-most 和 left-most derivations 形成相同的parse tree</p><p><strong>A parse tree has</strong>:</p><ol><li>Terminals at the leaves</li><li>Non-terminals at the interior nodes</li></ol><p>一个derivation定义了一颗parse tree</p><h3 id="二义性-ambiguity"><a class="markdownIt-Anchor" href="#二义性-ambiguity"></a> 二义性 Ambiguity</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929205102.png" width="500px"> </div><p>一个grammer是ambiguity的如果有超过一颗parse tree</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201001113537.png" width="500px"> </div><p>解决ambiguity的方法是重写grammer，改变优先级；或者可以通过定义优先级</p><h3 id="error-handing"><a class="markdownIt-Anchor" href="#error-handing"></a> Error Handing</h3><ul><li>Panic mode</li><li>Error productions</li><li>Automatic local or global correction</li></ul><h3 id="ast-抽象语法树"><a class="markdownIt-Anchor" href="#ast-抽象语法树"></a> AST 抽象语法树</h3><p>像parse trees但是忽略了一些细节</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002144333.png" width="300px"> </div><ul><li><p>从具体的语义抽象 =&gt; 更加紧凑 &amp; 简单</p></li><li><p>编译器中重要的数据结构</p></li></ul><h3 id="递归下降解析-recursive-descent-parsing"><a class="markdownIt-Anchor" href="#递归下降解析-recursive-descent-parsing"></a> 递归下降解析 Recursive Descent Parsing</h3><p>(第一个parsing算法)</p><p>一个top-down parsing算法</p><ul><li>The parse tree is constructed<ul><li>From the top</li><li>From left to right</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002152907.png" width="500px"> </div><h4 id="递归下降算法的一般描述"><a class="markdownIt-Anchor" href="#递归下降算法的一般描述"></a> 递归下降算法的一般描述</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002200003.png" width="400px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002200134.png" width="400px"> </div><ul><li><p>check TOKEN和当前输入流中所指的对象是否相等</p></li><li><p>检查和S的某一个产生式是否匹配</p></li><li><p>检查和S的任何产生式是否匹配</p></li></ul><p>一个编码的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002201258.png" width="400px"> </div><p>(PLUS: ’ + ')</p><ul><li>save保存初始指针</li><li>第一个产生式返回false则尝试第二个</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002201618.png" width="500px"> </div><h4 id="limitations-递归下降的局限性"><a class="markdownIt-Anchor" href="#limitations-递归下降的局限性"></a> Limitations 递归下降的局限性</h4><p>一旦找到一个能够用在非终结符元素的产生式的话，那么就没有回滚操作</p><ul><li>If a production for non-terminal X succeeds<ul><li>Cannot backtrack to try a different production for X later</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002204605.png" width="800px"> </div><ul><li>这边所讲的递归下降并不通用，但是容易实现</li><li>通过提取左因子 left factoring，可以对这个算法进行rewrite</li></ul><h3 id="左递归-left-recursion"><a class="markdownIt-Anchor" href="#左递归-left-recursion"></a> 左递归 Left Recursion</h3><p>递归下降算法中的主要难点</p><p>左递归的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002205539.png" width="300px"> </div><p><strong>Left Recursion 左递归</strong>:</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002205631.png" width="500px"> </div><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mi>a</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi>a</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi>a</mi><mi>a</mi><mo>…</mo></mrow><annotation encoding="application/x-tex">S\rightarrow Sa \rightarrow Saa \rightarrow Saaa \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span></p><p><strong>递归下降算法</strong>不适用于<strong>左递归</strong>情形</p><p>左递归语法的一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002210207.png" width="500px"> </div><p>主要原因是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>是最后的推导产生的，却在第一个位置，这不符合从左到右解析的原则</p><p><strong>可以使用右递归语法 right-recursion 进行重写</strong></p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002210454.png" width="500px"> </div><p><em>Dragon Book</em>中有消除左递归的具体算法</p><p>小结：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002211241.png" width="350px"> </div><p>一般编译器中都会采取手写praser的做法，如gcc</p><h3 id="预测解析-predictive-parsing"><a class="markdownIt-Anchor" href="#预测解析-predictive-parsing"></a> 预测解析 Predictive Parsing</h3><ul><li><p>类似递归下降，但是praser能预测使用哪个产生式</p><ul><li>looking at the next few tokens</li><li>不回滚</li></ul></li><li><p>预测praser能接受LL(k)语法 (left-to-right, left-most derivation, look forward k tokens)</p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003003010.png" width="350px"> </div><p>在递归下降算法中，每一步都有许多产生式选择，如果选择错了就回滚</p><p>在LL(1)中，每一步都只有一种选择</p><h4 id="we-need-to-left-factor-the-grammar-提取左公因子"><a class="markdownIt-Anchor" href="#we-need-to-left-factor-the-grammar-提取左公因子"></a> We need to left-factor the grammar 提取左公因子</h4><p><strong>目的</strong>：消除一个非终结符的多个产生式的公共前缀</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003111250.png" width="250px"> </div><p>通过提取左公因式，可以将产生式的执行推迟进行，先prase公共的非终结符</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113332.png" width="500px"> </div><p>通过grammar生成parsing table</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113423.png" width="500px"> </div><ul><li><p>方法与递归下降类似，除了</p><ul><li>对于最左的非终结符S</li><li>look at下一个token</li><li>在表中找到对应的产生式</li></ul></li><li><p>用一个栈来存放之前的parse tree，栈顶是当前要parse的非终结符或者终结符</p></li></ul><p>算法：</p><p>($符号表示end of input)</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113459.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113532.png" width="500px"> </div>]]></content>
      
      
      <categories>
          
          <category> 编译 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS143 编译原理-1</title>
      <link href="/2020/09/28/cs143-1/"/>
      <url>/2020/09/28/cs143-1/</url>
      
        <content type="html"><![CDATA[<ul><li>编译器结构<ol><li>词法分析 (Lexical Analysis)</li><li>语法分析 (Parsing)</li><li>语义分析 (Semantic Analysis)</li><li>优化 (Optimization)</li><li>代码生成 (Code Generation)</li></ol></li></ul><p>早期的编译器和现在的编译器的对比：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927155639.png" width="500px"> </div><p>现在的编译器花了更多的时间在优化上面</p><h2 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h2><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927160531.png" width="500px"> </div><p>“Words” =&gt; “Tokens Class”: <strong>Identifier</strong>, <strong>keywords</strong>, ‘<strong>(</strong>’, ‘<strong>)</strong>’, <strong>numbers</strong>, …</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927160906.png" width="500px"> </div><p>词法分析器将字符子串分类成Tokens，传递给<strong>Parser</strong></p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927161438.png" width="500px"> </div><ul><li>Left-to-right scan =&gt; lookahead sometimes required 有时候需要向前几个字符参考，来确定当前的token</li></ul><h3 id="正则语言-regular-languages"><a class="markdownIt-Anchor" href="#正则语言-regular-languages"></a> 正则语言 Regular Languages</h3><ul><li>Regular expressions</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927164524.png" width="280px"> </div><p><strong>Epsilon</strong>不是空集，是一个只包含空字符的集合</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927164758.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927165627.png" width="500px"> </div><p>grammar: 文法</p><ul><li>Regular expressions (syntax) specify regular languages (set of strings)</li></ul><h3 id="形式化语言-formal-languages"><a class="markdownIt-Anchor" href="#形式化语言-formal-languages"></a> 形式化语言 Formal Languages</h3><ul><li><p><strong>Def.</strong> Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> be a set of characters (an alphabet).</p><p>A <strong>language</strong> over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> is a set of strings of characters drawn from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span></p></li><li><p>Meaning function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> maps <strong>syntax</strong> to <strong>semantics</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>:</mo><mi>E</mi><mi>x</mi><mi>p</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>s</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">L: Exp\rightarrow Sets\ of\ Strings</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">s</span></span></span></span></p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927172527.png" width="500px"> </div><ul><li>Meaning is many to one<ul><li>Never one to many!</li></ul></li></ul><h3 id="lexical-specifications"><a class="markdownIt-Anchor" href="#lexical-specifications"></a> Lexical Specifications</h3><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msup><mi>A</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">AA^*=A^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232010.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232447.png" width="500px"> </div><p>最后一个表示补集</p><ul><li>如何预测一个s是不是属于L®</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232857.png" width="500px"> </div><p>写出所有类型token的正则表达式</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232923.png" width="500px"> </div><p>构建R，R能匹配所有类型的token</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927234514.png" width="500px"> </div><p>检查前缀是不是属于R，如果属于R，则一定属于R中的某个token类Rj，删除匹配完成的前缀接着进行第三步</p><p><strong>一些问题</strong>：</p><ol><li><p>当较短和较长的字符串都匹配时，选较长的  “Maximal Match”</p></li><li><p>当同一个字符串和多个正则表达式匹配时，根据优先级</p></li><li><p>What if no rule matches? 添加一个错误类，优先级设置成最低</p></li></ol><h3 id="有限自动机"><a class="markdownIt-Anchor" href="#有限自动机"></a> 有限自动机</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928001815.png" width="450px"> </div><p>有限自动机是一种算法的实现</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928002027.png" width="450px"> </div><ul><li>在一个状态，读取一些输入，变成另一个状态</li><li>如果读完输入，最后处于接受状态，则accept，否则就reject</li></ul><h4 id="dfa-deterministic-finite-automata-确定的有限状态自动机"><a class="markdownIt-Anchor" href="#dfa-deterministic-finite-automata-确定的有限状态自动机"></a> DFA (Deterministic Finite Automata) 确定的有限状态自动机</h4><ul><li>对于一个input，只能有一个转换</li><li>NO <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>-moves</li><li>执行更快，因为每一步都没有选择</li></ul><h4 id="nfa-nondeterministic-finite-automata-不确定的优先状态自动机"><a class="markdownIt-Anchor" href="#nfa-nondeterministic-finite-automata-不确定的优先状态自动机"></a> NFA (Nondeterministic Finite Automata) 不确定的优先状态自动机</h4><ul><li>对于一个input，可以有多个转换</li><li>have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>-moves</li><li>smaller</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928153706.png" width="250px"> </div><h3 id="正则表达式-nfas"><a class="markdownIt-Anchor" href="#正则表达式-nfas"></a> 正则表达式 =&gt; NFAs</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161156.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928154159.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928154222.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160059.png" width="500px"> </div><p>一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160203.png" width="500px"> </div><h3 id="nfa-to-dfa"><a class="markdownIt-Anchor" href="#nfa-to-dfa"></a> NFA to DFA</h3><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi><mo>−</mo><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\epsilon -closure</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160434.png" width="500px"> </div><p>相应的<strong>DFA</strong>：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161008.png" width="500px"> </div><h3 id="implementing-finite-automata"><a class="markdownIt-Anchor" href="#implementing-finite-automata"></a> Implementing Finite Automata</h3><p>DFA可以用一张二维的表来表示：</p><ol><li>一维是states</li><li>一维是输入符号</li><li>表中是转换的下一个states</li></ol><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161404.png" width="250px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161500.png" width="500px"> </div><p>一种更加节省空间的做法：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161534.png" width="500px"> </div><p>NFA直接转换成table：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161835.png" width="500px"> </div><p>节省空间，但是这样比NFA=&gt;DFA=&gt;table慢</p>]]></content>
      
      
      <categories>
          
          <category> 编译 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS143 编译原理-3</title>
      <link href="/2020/09/28/cs143-3/"/>
      <url>/2020/09/28/cs143-3/</url>
      
        <content type="html"><![CDATA[<h2 id="语法分析2"><a class="markdownIt-Anchor" href="#语法分析2"></a> 语法分析2</h2><h3 id="first集"><a class="markdownIt-Anchor" href="#first集"></a> First集</h3><h4 id="如何构建parsing-table-构建ll1parsing-table需要哪些条件"><a class="markdownIt-Anchor" href="#如何构建parsing-table-构建ll1parsing-table需要哪些条件"></a> 如何构建parsing table 构建LL(1)parsing table需要哪些条件</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003132022.png" width="600px"> </div><p>[上图解释]</p><p>给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>α</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">A, \alpha, t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span></span></span></span> 在什么情况下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">T[A, t]=\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>能成立？</p><p>第一种情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>通过一步或多步推导能推出t，且t处在第一个位置，这时候说t属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的First集；</p><p>第二种情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>不能直接推出t（t不属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的First集），但A能推出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>能推出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>，且在某个产生式中t位置在A后，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">T[A, t]=\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>也能成立，且称t属于A的Follow集</p><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003135005.png" width="300px"> </div><p>一些可推规则：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003135447.png" width="500px"> </div><p>求First集的一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003140150.png" width="500px"> </div><h3 id="follow集"><a class="markdownIt-Anchor" href="#follow集"></a> Follow集</h3><h4 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003162550.png" width="300px"> </div><p>一些可推规则：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003163011.png" width="400px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003163151.png" width="400px"> </div><p>求First集的一个例子，需要用到First集：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003164657.png" width="600px"> </div><h3 id="ll1-pasring-tables"><a class="markdownIt-Anchor" href="#ll1-pasring-tables"></a> LL(1) Pasring Tables</h3><p>使用First集和Follow集来构建LL(1) parsing table</p><p>目的：对于CFG G，构建一个parsing table T</p><p>对每一个在G中的产生式进行以下算法：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003170101.png" width="400px"> </div><p>考虑每个生成式在右侧第一个位置能生成什么</p><p>一个生成LL(1) parsing table 的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003170958.png" width="550px"> </div><p>如果走到了表格中的空白区域则说明解析错误</p><p>如果对一个左递归的grammar构建parsing table：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">S\rightarrow Sa|b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord mathdefault">b</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003171506.png" width="400px"> </div><p>构建出来的parsing table中的某些单元格中可能存在多种选择，则这个语法不是LL(1)的</p><p>[not left factored] [left recursive] [ambiguous] [other] 都不是LL(1)的，实际上大多数编程语言的CFG都不是LL(1)的，LL(1)语法太弱</p><h3 id="自下而上的解析-bottom-up-parsing"><a class="markdownIt-Anchor" href="#自下而上的解析-bottom-up-parsing"></a> 自下而上的解析 Bottom-Up Parsing</h3>]]></content>
      
      
      <categories>
          
          <category> 编译 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构-1</title>
      <link href="/2020/04/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"/>
      <url>/2020/04/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串sds"><a class="markdownIt-Anchor" href="#简单动态字符串sds"></a> 简单动态字符串sds</h2><p>sds 的源码主要在 sds.h 和 sds.c 中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 buf 数组是柔性数组，在分配的时候不占内存大小</p><p>sds.h 中还有两个 inline 的静态函数，用于返回实际保存的字符串长度和可用空间的字符串长度</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span> <span class="comment">//buf地址往回sizeof(struct sdshdr))</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 可用空间的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边用了一个骚操作，用 buf 的数组指针减去8字节，就得到了结构体的初始位置，也就是结构体的指针：</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/redis/20200502162607.png" height="180px"></div>这个技巧在 redis 中多处用到<p>sds 主要接口函数声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 sds T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定字符串 init ，创建一个包含同样字符串的 sds T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个只保存了空字符串 "" 的 sds T = O(1)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sds 实际保存的字符串的长度 T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制给定 sds 的副本 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放给定的 sds T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sds 可用空间的长度 T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 sds 扩充至指定长度，未使用的空间以 0 字节填充 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定字符串 t 追加到 sds 的末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将另一个 sds 追加到一个 sds 的末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串 t 的前 len 个字符复制到 sds s 当中，并在字符串的最后添加终结符 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串复制到 sds 当中，覆盖原有的字符 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;</span><br></pre></td></tr></table></figure><p>其中几个：</p><ul><li><strong>sdsnew</strong><br />根据给定字符串 init ，创建一个包含同样字符串的 sds</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用了：</p><ul><li><strong>sdsnewlen</strong><br />根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>); <span class="comment">// 结构体+buf数组+'\0'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 zmalloc 和 zcalloc 为 redis 使用的内存管理工具，在 zmalloc.c 和 zmalloc.h 中定义</p><h2 id="双端链表"><a class="markdownIt-Anchor" href="#双端链表"></a> 双端链表</h2><p>双端链表 的源码主要在 adlist.h 和 adlist.c 中</p><p>双端链表节点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>双端链表结构:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>为了规范化的宏定义函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回给定链表所包含的节点数量</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表头节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表尾节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="comment">// 返回给定节点的前置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="comment">// 返回给定节点的后置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="comment">// 返回给定节点的值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表 l 的值复制函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="comment">// 将链表 l 的值释放函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="comment">// 将链表的对比函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的值复制函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值释放函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值对比函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure><p>几个主要接口函数：</p><ul><li><strong>listCreate</strong><br />创建一个新的链表 T = O(1)</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listRelease</strong><br />释放整个链表，以及链表中所有节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向头指针</span></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// 遍历整个链表</span></span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放节点结构</span></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表结构</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listAddNodeHead</strong><br />将一个包含有给定值指针 value 的新节点添加到链表的表头</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值指针</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点到空链表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 添加节点到非空链表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 redis 双端队列中使用了迭代器这一技巧</p><p>双端链表迭代器：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前迭代到的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代的方向</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line"></span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure><ul><li><strong>listGetIterator</strong><br />为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为迭代器分配内存</span></span><br><span class="line">    listIter *iter;</span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录迭代方向</span></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listNext</strong><br />返回迭代器当前所指向的节点<br />这个函数其实有两个作用：返回当前迭代器指向的节点 + 使迭代器指向下一个节点（我刚开始还没明白只return了一个current，怎么把iter传出去，后来看了这个函数的使用才知道，因为函数传入的是指针，只要定义一个listIter类型的指针，一直使用该函数就能迭代了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据方向选择下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listDup</strong><br />复制整个链表<br />其中就使用了上述的listNext来进行迭代</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新链表</span></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置节点值处理函数</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代整个输入链表</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制节点值到新节点</span></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将节点添加到链表</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回副本</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
