<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS143 编译原理-1</title>
      <link href="/2020/09/28/cs143-1/"/>
      <url>/2020/09/28/cs143-1/</url>
      
        <content type="html"><![CDATA[<ul><li>编译器结构<ol><li>词法分析 (Lexical Analysis)</li><li>语法分析 (Parsing)</li><li>语义分析 (Semantic Analysis)</li><li>优化 (Optimization)</li><li>代码生成 (Code Generation)</li></ol></li></ul><p>早期的编译器和现在的编译器的对比：</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927155639.png" width="500px"></div><p>现在的编译器花了更多的时间在优化上面</p><h2 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h2><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927160531.png" width="500px"></div><p>“Words” =&gt; “Tokens Class”: <strong>Identifier</strong>, <strong>keywords</strong>, ‘<strong>(</strong>’, ‘<strong>)</strong>’, <strong>numbers</strong>, …</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927160906.png" width="500px"></div><p>词法分析器将字符子串分类成Tokens，传递给<strong>Parser</strong></p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927161438.png" width="500px"></div><ul><li>Left-to-right scan =&gt; lookahead sometimes required 有时候需要向前几个字符参考，来确定当前的token</li></ul><h3 id="正则语言-regular-languages"><a class="markdownIt-Anchor" href="#正则语言-regular-languages"></a> 正则语言 Regular Languages</h3><ul><li>Regular expressions</li></ul><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927164524.png" width="280px"></div><p><strong>Epsilon</strong>不是空集，是一个只包含空字符的集合</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927164758.png" width="500px"></div><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927165627.png" width="500px"></div><p>grammar: 文法</p><ul><li>Regular expressions (syntax) specify regular languages (set of strings)</li></ul><h3 id="形式化语言-formal-languages"><a class="markdownIt-Anchor" href="#形式化语言-formal-languages"></a> 形式化语言 Formal Languages</h3><ul><li><p><strong>Def.</strong> Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> be a set of characters (an alphabet).</p><p>A <strong>language</strong> over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> is a set of strings of characters drawn from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span></p></li><li><p>Meaning function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> maps <strong>syntax</strong> to <strong>semantics</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>:</mo><mi>E</mi><mi>x</mi><mi>p</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>s</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">L: Exp\rightarrow Sets\ of\ Strings</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">s</span></span></span></span></p></li></ul><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927172527.png" width="500px"></div><ul><li>Meaning is many to one<ul><li>Never one to many!</li></ul></li></ul><h3 id="lexical-specifications"><a class="markdownIt-Anchor" href="#lexical-specifications"></a> Lexical Specifications</h3><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msup><mi>A</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">AA^*=A^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></li></ul><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232010.png" width="500px"></div><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232447.png" width="500px"></div><p>最后一个表示补集</p><ul><li>如何预测一个s是不是属于L®</li></ul><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232857.png" width="500px"></div><p>写出所有类型token的正则表达式</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232923.png" width="500px"></div><p>构建R，R能匹配所有类型的token</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927234514.png" width="500px"></div><p>检查前缀是不是属于R，如果属于R，则一定属于R中的某个token类Rj，删除匹配完成的前缀接着进行第三步</p><p><strong>一些问题</strong>：</p><ol><li><p>当较短和较长的字符串都匹配时，选较长的  “Maximal Match”</p></li><li><p>当同一个字符串和多个正则表达式匹配时，根据优先级</p></li><li><p>What if no rule matches? 添加一个错误类，优先级设置成最低</p></li></ol><h3 id="有限自动机"><a class="markdownIt-Anchor" href="#有限自动机"></a> 有限自动机</h3><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928001815.png" width="450px"></div><p>有限自动机是一种算法的实现</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928002027.png" width="450px"></div><ul><li>在一个状态，读取一些输入，变成另一个状态</li><li>如果读完输入，最后处于接受状态，则accept，否则就reject</li></ul><h4 id="dfa-deterministic-finite-automata-确定的有限状态自动机"><a class="markdownIt-Anchor" href="#dfa-deterministic-finite-automata-确定的有限状态自动机"></a> DFA (Deterministic Finite Automata) 确定的有限状态自动机</h4><ul><li>对于一个input，只能有一个转换</li><li>NO <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>-moves</li><li>执行更快，因为每一步都没有选择</li></ul><h4 id="nfa-nondeterministic-finite-automata-不确定的优先状态自动机"><a class="markdownIt-Anchor" href="#nfa-nondeterministic-finite-automata-不确定的优先状态自动机"></a> NFA (Nondeterministic Finite Automata) 不确定的优先状态自动机</h4><ul><li>对于一个input，可以有多个转换</li><li>have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>-moves</li><li>smaller</li></ul><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928153706.png" width="250px"></div><h3 id="正则表达式-nfas"><a class="markdownIt-Anchor" href="#正则表达式-nfas"></a> 正则表达式 =&gt; NFAs</h3><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161156.png" width="500px"> </div><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928154159.png" width="500px"></div><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928154222.png" width="500px"></div><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160059.png" width="500px"> </div><p>一个例子：</p><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160203.png" width="500px"> </div><h3 id="nfa-to-dfa"><a class="markdownIt-Anchor" href="#nfa-to-dfa"></a> NFA to DFA</h3><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi><mo>−</mo><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\epsilon -closure</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span></li></ul><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160434.png" width="500px"> </div><p>相应的<strong>DFA</strong>：</p><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161008.png" width="500px"> </div><h3 id="implementing-finite-automata"><a class="markdownIt-Anchor" href="#implementing-finite-automata"></a> Implementing Finite Automata</h3><p>DFA可以用一张二维的表来表示：</p><ol><li>一维是states</li><li>一维是输入符号</li><li>表中是转换的下一个states</li></ol><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161404.png" width="500px"> </div><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161500.png" width="500px"> </div><p>一种更加节省空间的做法：</p><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161534.png" width="500px"> </div><p>NFA直接转换成table：</p><div align='center'>   <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161835.png" width="500px"> </div><p>节省空间，但是这样比NFA=&gt;DFA=&gt;table慢</p>]]></content>
      
      
      <categories>
          
          <category> 编译 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构-1</title>
      <link href="/2020/04/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"/>
      <url>/2020/04/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串sds"><a class="markdownIt-Anchor" href="#简单动态字符串sds"></a> 简单动态字符串sds</h2><p>sds 的源码主要在 sds.h 和 sds.c 中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 buf 数组是柔性数组，在分配的时候不占内存大小</p><p>sds.h 中还有两个 inline 的静态函数，用于返回实际保存的字符串长度和可用空间的字符串长度</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span> <span class="comment">//buf地址往回sizeof(struct sdshdr))</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 可用空间的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边用了一个骚操作，用 buf 的数组指针减去8字节，就得到了结构体的初始位置，也就是结构体的指针：</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/redis/20200502162607.png" height="180px"></div>这个技巧在 redis 中多处用到<p>sds 主要接口函数声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 sds T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定字符串 init ，创建一个包含同样字符串的 sds T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个只保存了空字符串 "" 的 sds T = O(1)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sds 实际保存的字符串的长度 T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制给定 sds 的副本 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放给定的 sds T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sds 可用空间的长度 T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 sds 扩充至指定长度，未使用的空间以 0 字节填充 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定字符串 t 追加到 sds 的末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将另一个 sds 追加到一个 sds 的末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串 t 的前 len 个字符复制到 sds s 当中，并在字符串的最后添加终结符 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串复制到 sds 当中，覆盖原有的字符 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;</span><br></pre></td></tr></table></figure><p>其中几个：</p><ul><li><strong>sdsnew</strong><br />根据给定字符串 init ，创建一个包含同样字符串的 sds</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用了：</p><ul><li><strong>sdsnewlen</strong><br />根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>); <span class="comment">// 结构体+buf数组+'\0'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 zmalloc 和 zcalloc 为 redis 使用的内存管理工具，在 zmalloc.c 和 zmalloc.h 中定义</p><h2 id="双端链表"><a class="markdownIt-Anchor" href="#双端链表"></a> 双端链表</h2><p>双端链表 的源码主要在 adlist.h 和 adlist.c 中</p><p>双端链表节点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>双端链表结构:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>为了规范化的宏定义函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回给定链表所包含的节点数量</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表头节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表尾节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="comment">// 返回给定节点的前置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="comment">// 返回给定节点的后置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="comment">// 返回给定节点的值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表 l 的值复制函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="comment">// 将链表 l 的值释放函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="comment">// 将链表的对比函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的值复制函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值释放函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值对比函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure><p>几个主要接口函数：</p><ul><li><strong>listCreate</strong><br />创建一个新的链表 T = O(1)</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listRelease</strong><br />释放整个链表，以及链表中所有节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向头指针</span></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// 遍历整个链表</span></span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放节点结构</span></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表结构</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listAddNodeHead</strong><br />将一个包含有给定值指针 value 的新节点添加到链表的表头</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值指针</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点到空链表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 添加节点到非空链表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 redis 双端队列中使用了迭代器这一技巧</p><p>双端链表迭代器：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前迭代到的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代的方向</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line"></span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure><ul><li><strong>listGetIterator</strong><br />为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为迭代器分配内存</span></span><br><span class="line">    listIter *iter;</span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录迭代方向</span></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listNext</strong><br />返回迭代器当前所指向的节点<br />这个函数其实有两个作用：返回当前迭代器指向的节点 + 使迭代器指向下一个节点（我刚开始还没明白只return了一个current，怎么把iter传出去，后来看了这个函数的使用才知道，因为函数传入的是指针，只要定义一个listIter类型的指针，一直使用该函数就能迭代了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据方向选择下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listDup</strong><br />复制整个链表<br />其中就使用了上述的listNext来进行迭代</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新链表</span></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置节点值处理函数</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代整个输入链表</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制节点值到新节点</span></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将节点添加到链表</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回副本</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
