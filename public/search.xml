<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[LeetCode] 动态规划</title>
      <link href="/2020/12/06/leetcode/lc-dp/"/>
      <url>/2020/12/06/leetcode/lc-dp/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2><p>用一个dp数组来保存以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为结尾的一个子序列的某种性质，再用一个全局变量记录其中的最值。</p><h4 id="leetcode-53-最大子序和"><a class="markdownIt-Anchor" href="#leetcode-53-最大子序和"></a> Leetcode 53 <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></h4><blockquote><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x: nums) &#123;</span><br><span class="line">            pre = <span class="built_in">max</span>(pre + x, x);</span><br><span class="line">            maxAns = <span class="built_in">max</span>(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-91-解码方法"><a class="markdownIt-Anchor" href="#leetcode-91-解码方法"></a> Leetcode 91 <a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">解码方法</a></h4><blockquote><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">'A'</span> -&gt; 1</span><br><span class="line"><span class="string">'B'</span> -&gt; 2</span><br><span class="line">...</span><br><span class="line"><span class="string">'Z'</span> -&gt; 26</span><br></pre></td></tr></table></figure><p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p>题目数据保证答案肯定是一个 32 位的整数。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a!=<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a==<span class="string">'1'</span>||a==<span class="string">'2'</span>&amp;&amp;b&lt;=<span class="string">'6'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>||s[<span class="number">0</span>]==<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> check(s[<span class="number">0</span>]);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=check(s[<span class="number">1</span>])+func(s[<span class="number">0</span>],s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(s[i]))</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(func(s[i<span class="number">-1</span>],s[i]))</span><br><span class="line">                dp[i]+=dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#leetcode-121-买卖股票的最佳时机"></a> Leetcode 121 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></h4><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[<span class="number">1</span>]&gt;prices[<span class="number">0</span>])<span class="keyword">return</span> prices[<span class="number">1</span>]-prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            prices[i]=prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        prices.pop_back();</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i:prices)&#123;</span><br><span class="line">            pre=<span class="built_in">max</span>(i,pre+i);</span><br><span class="line">            max_sum=<span class="built_in">max</span>(pre,max_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_sum&gt;<span class="number">0</span>)<span class="keyword">return</span> max_sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-139-单词拆分"><a class="markdownIt-Anchor" href="#leetcode-139-单词拆分"></a> Leetcode 139 <a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h4><blockquote><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br />你可以假设字典中没有重复的单词。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="keyword">word</span>:wordDict)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">set</span>.insert(<span class="keyword">word</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;<span class="comment">//空字符串合法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]&amp;&amp;<span class="built_in">set</span>.<span class="built_in">find</span>(s.substr(j,i-j))!=<span class="built_in">set</span>.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-152-乘积最大子数组"><a class="markdownIt-Anchor" href="#leetcode-152-乘积最大子数组"></a> Leetcode 152 <a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h4><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=nums[<span class="number">0</span>],maxValue=nums[<span class="number">0</span>],minValue=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tempMax=<span class="built_in">max</span>(nums[i],maxValue*nums[i]);</span><br><span class="line">            <span class="keyword">int</span> tempMin=<span class="built_in">min</span>(nums[i],maxValue*nums[i]);</span><br><span class="line">            maxValue=<span class="built_in">max</span>(tempMax,minValue*nums[i]);</span><br><span class="line">            minValue=<span class="built_in">min</span>(tempMin,minValue*nums[i]);</span><br><span class="line">            result=<span class="built_in">max</span>(maxValue,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//因为是乘法，和最大最小值有关，所以用两个dp数组</span></span><br></pre></td></tr></table></figure><h4 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍"></a> 198 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h4><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="built_in">size</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="built_in">size</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">size</span><span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-264-丑数-ii"><a class="markdownIt-Anchor" href="#leetcode-264-丑数-ii"></a> Leetcode 264 <a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">丑数 II</a></h4><blockquote><p>编写一个程序，找出第 n 个丑数。</p><p>丑数就是质因数只包含 2, 3, 5 的正整数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nums[<span class="number">1691</span>];</span><br><span class="line">        nums[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">int</span> ugly=<span class="built_in">min</span>(nums[p2]*<span class="number">2</span>,<span class="built_in">min</span>(nums[p3]*<span class="number">3</span>,nums[p5]*<span class="number">5</span>));</span><br><span class="line">             nums[i]=ugly;</span><br><span class="line">             <span class="keyword">if</span>(ugly==nums[p2]*<span class="number">2</span>) p2++;</span><br><span class="line">             <span class="keyword">if</span>(ugly==nums[p3]*<span class="number">3</span>) p3++;</span><br><span class="line">             <span class="keyword">if</span>(ugly==nums[p5]*<span class="number">5</span>) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-300-最长上升子序列"><a class="markdownIt-Anchor" href="#leetcode-300-最长上升子序列"></a> Leetcode 300 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h4><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxAns=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(length,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxAns=<span class="built_in">max</span>(maxAns,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-1143-最长公共子序列-二维dp"><a class="markdownIt-Anchor" href="#leetcode-1143-最长公共子序列-二维dp"></a> Leetcode 1143 <a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列</a> (二维DP)</h4><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br />例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=text1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len2=text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len1==<span class="number">0</span>||len2==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LeetCode] 链表</title>
      <link href="/2020/12/06/leetcode/lc-linklist/"/>
      <url>/2020/12/06/leetcode/lc-linklist/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2><h4 id="leetcode-146-lru缓存机制"><a class="markdownIt-Anchor" href="#leetcode-146-lru缓存机制"></a> Leetcode 146 <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></h4><blockquote><p>运用你所掌握的数据结构，设计和实现一个 <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU (最近最少使用) 缓存机制</a> 。</p><p>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(<span class="number">0</span>), value(<span class="number">0</span>), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    DLinkedNode(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): key(_key), value(_value), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> _capacity): capacity(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++<span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">size</span> &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --<span class="built_in">size</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-148-排序链表"><a class="markdownIt-Anchor" href="#leetcode-148-排序链表"></a> Leetcode 148 <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></h4><blockquote><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = getLength(head);</span><br><span class="line">ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>; <span class="built_in">step</span> &lt; length; <span class="built_in">step</span> *= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* pre = dummy;</span><br><span class="line">ListNode* cur = dummy-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* h1 = cur;</span><br><span class="line">ListNode* h2 = splitList(h1, <span class="built_in">step</span>);</span><br><span class="line">cur = splitList(h2, <span class="built_in">step</span>);</span><br><span class="line">ListNode* tmpMerge = mergeList(h1, h2);</span><br><span class="line">pre-&gt;next = tmpMerge;</span><br><span class="line"><span class="keyword">while</span> (pre-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">splitList</span><span class="params">(ListNode* head, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">dummy-&gt;next = head;</span><br><span class="line">ListNode* pre = dummy;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">step</span>--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (head!= <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* h1, ListNode* h2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">ListNode* pre = dummy;</span><br><span class="line"><span class="keyword">while</span> (h1 != <span class="literal">nullptr</span> &amp;&amp; h2 != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (h1-&gt;val &lt; h2-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next = h1;</span><br><span class="line">h1 = h1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;next = h2;</span><br><span class="line">h2 = h2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (h1 != <span class="literal">nullptr</span>) pre-&gt;next = h1;</span><br><span class="line"><span class="keyword">if</span> (h2 != <span class="literal">nullptr</span>) pre-&gt;next = h2;</span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用迭代的方法，进行归并</p><h4 id="leetcode-206-反转链表"><a class="markdownIt-Anchor" href="#leetcode-206-反转链表"></a> Leetcode 206 <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h4><blockquote><p>反转一个单链表。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LeetCode] 滑动窗口</title>
      <link href="/2020/12/06/leetcode/lc-slide-window/"/>
      <url>/2020/12/06/leetcode/lc-slide-window/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2><h4 id="leetcode-3-无重复字符的最长子串"><a class="markdownIt-Anchor" href="#leetcode-3-无重复字符的最长子串"></a> Leetcode 3 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a></h4><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c[s[i<span class="number">-1</span>]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (rk + <span class="number">1</span> &lt; len &amp;&amp; c[s[rk+<span class="number">1</span>]] == <span class="number">0</span>) &#123;</span><br><span class="line">c[s[rk+<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">rk++;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LeetCode] 二叉树</title>
      <link href="/2020/12/06/leetcode/lc-tree/"/>
      <url>/2020/12/06/leetcode/lc-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2><h4 id="leetcode-94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#leetcode-94-二叉树的中序遍历"></a> Leetcode 94 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h4><blockquote><p>给定一个二叉树，返回它的中序 遍历。</p><p>示例:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,null,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></blockquote><p>递归解法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-95-不同的二叉搜索树-ii"><a class="markdownIt-Anchor" href="#leetcode-95-不同的二叉搜索树-ii"></a> Leetcode 95 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">不同的二叉搜索树 II</a></h4><blockquote><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;<span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=<span class="built_in">end</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees=generateTrees(start,i<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees=generateTrees(i+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;lTree:leftTrees)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;rTree:rightTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* node=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    node-&gt;right=rTree;</span><br><span class="line">                    node-&gt;left=lTree;</span><br><span class="line">                    allTrees.push_back(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-101-对称二叉树"><a class="markdownIt-Anchor" href="#leetcode-101-对称二叉树"></a> Leetcode 101 <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h4><blockquote><p>给定一个二叉树，检查它是否是镜像对称的。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(TreeNode *left,TreeNode *right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">NULL</span>&amp;&amp;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">NULL</span>&amp;&amp;right!=<span class="literal">NULL</span>&amp;&amp;left-&gt;val==right-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> func(left-&gt;left,right-&gt;right)&amp;&amp;func(left-&gt;right,right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> func(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LeetCode] Index</title>
      <link href="/2020/12/06/leetcode/leetcode/"/>
      <url>/2020/12/06/leetcode/leetcode/</url>
      
        <content type="html"><![CDATA[<h2 id="leetcode"><a class="markdownIt-Anchor" href="#leetcode"></a> Leetcode</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LeetCode] 回溯</title>
      <link href="/2020/12/06/leetcode/lc-backtracking/"/>
      <url>/2020/12/06/leetcode/lc-backtracking/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h2><h4 id="leetcode-46-全排列"><a class="markdownIt-Anchor" href="#leetcode-46-全排列"></a> Leetcode 46 <a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h4><blockquote><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;output,<span class="keyword">int</span> first,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==len)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;len;i++)&#123;</span><br><span class="line">            swap(output[i],output[first]);</span><br><span class="line">            backtrace(res,output,first+<span class="number">1</span>,len);</span><br><span class="line">            swap(output[i],output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        backtrace(res,nums,<span class="number">0</span>,(<span class="keyword">int</span>)nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LeetCode] DFS</title>
      <link href="/2020/12/06/leetcode/lc-dfs/"/>
      <url>/2020/12/06/leetcode/lc-dfs/</url>
      
        <content type="html"><![CDATA[<h2 id="深度优先遍历"><a class="markdownIt-Anchor" href="#深度优先遍历"></a> 深度优先遍历</h2><h4 id="leetcode-22-括号生成"><a class="markdownIt-Anchor" href="#leetcode-22-括号生成"></a> Leetcode 22 <a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></h4><blockquote><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[</span><br><span class="line">       <span class="string">"((()))"</span>,</span><br><span class="line">       <span class="string">"(()())"</span>,</span><br><span class="line">       <span class="string">"(())()"</span>,</span><br><span class="line">       <span class="string">"()(())"</span>,</span><br><span class="line">       <span class="string">"()()()"</span></span><br><span class="line">     ]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="string">""</span>,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> cur,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)dfs(cur+<span class="string">"("</span>,left<span class="number">-1</span>,right+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;<span class="number">0</span>)dfs(cur+<span class="string">")"</span>,left,right<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LeetCode] 双指针</title>
      <link href="/2020/12/06/leetcode/lc-double-pointer/"/>
      <url>/2020/12/06/leetcode/lc-double-pointer/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h2><h4 id="leetcode-19-删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#leetcode-19-删除链表的倒数第n个节点"></a> Leetcode 19 <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a></h4><blockquote><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; stk;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            stk.push(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = stk.top();</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[C++] 遍历tuple</title>
      <link href="/2020/12/06/C++/traversal-tuple/"/>
      <url>/2020/12/06/C++/traversal-tuple/</url>
      
        <content type="html"><![CDATA[<h2 id="遍历tuple"><a class="markdownIt-Anchor" href="#遍历tuple"></a> 遍历tuple</h2><h4 id="常规思维错误方法"><a class="markdownIt-Anchor" href="#常规思维错误方法"></a> 常规思维错误方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; ++i)</span><br><span class="line">        os &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;i&gt;(t); <span class="comment">// i 出错</span></span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; make_tuple(<span class="string">"InsideZhang"</span>, <span class="number">23</span>, <span class="string">"HeNan"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 编译出错，局部变量i不可作为非类型模板参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c11-正确方法"><a class="markdownIt-Anchor" href="#c11-正确方法"></a> C++11 正确方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tuple, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple_print</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Tuple&amp; t, <span class="built_in">std</span>::ostream&amp; os)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tuple_print&lt;Tuple, N<span class="number">-1</span>&gt;::<span class="built_in">print</span>(t, os);</span><br><span class="line">        os &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;N<span class="number">-1</span>&gt;(t); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类模板的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple_print</span>&lt;Tuple, 1&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Tuple&amp; t, <span class="built_in">std</span>::ostream&amp; os)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator&lt;&lt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operaotr&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    tuple_print&lt;<span class="keyword">decltype</span>(t), <span class="keyword">sizeof</span>...(Args)&gt;::<span class="built_in">print</span>(t, os);</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c14方法"><a class="markdownIt-Anchor" href="#c14方法"></a> C++14方法</h3><p>通过<code>integer_sequence</code>快速实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tuple, <span class="keyword">int</span>... N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Tuple&amp; t, <span class="built_in">std</span>::index_sequence&lt;N...&gt;)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&#123; ((<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;N&gt;(t) &lt;&lt; <span class="string">" "</span>), <span class="number">0</span>)... &#125;;</span><br><span class="line"><span class="comment">//((std::cout &lt;&lt; std::get&lt;N&gt;(t) &lt;&lt; std::endl), ...); c++17 fold表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;Args...&gt;&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">print</span>(t, <span class="built_in">std</span>::index_sequence_for&lt;Args...&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="string">"hello"</span>, <span class="number">1</span>, <span class="string">"world"</span>, <span class="number">2</span>, <span class="string">"!"</span>, i);</span><br><span class="line">fun(t);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>库中辅助函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span>... _Vals&gt;</span><br><span class="line"><span class="keyword">using</span> index_sequence = integer_sequence&lt;<span class="keyword">size_t</span>, _Vals...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> _Size&gt;</span><br><span class="line"><span class="keyword">using</span> make_index_sequence = make_integer_sequence&lt;<span class="keyword">size_t</span>, _Size&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">index_sequence_for</span> = <span class="title">make_index_sequence</span>&lt;sizeof...(_Types)&gt;;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tuple </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[6.824] MapReduce Lab</title>
      <link href="/2020/12/06/6.824/mapreduce-lab/"/>
      <url>/2020/12/06/6.824/mapreduce-lab/</url>
      
        <content type="html"><![CDATA[<h2 id="maprudece-lab"><a class="markdownIt-Anchor" href="#maprudece-lab"></a> MapRudece Lab</h2><h3 id="master-节点"><a class="markdownIt-Anchor" href="#master-节点"></a> Master 节点</h3><p>MapReduce是一个分布式计算模型，这是MapReduce的go语言版本的一个简单实现。</p><ul><li>mrmaster.go</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Usage: mrmaster inputfiles...\n"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := mr.MakeMaster(os.Args[<span class="number">1</span>:], <span class="number">10</span>) <span class="comment">//创建一个master</span></span><br><span class="line"><span class="keyword">for</span> m.Done() == <span class="literal">false</span> &#123; <span class="comment">//主线程等待结束</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>master.go</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create a Master.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeMaster</span><span class="params">(files []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>)</span> *<span class="title">Master</span></span> &#123;</span><br><span class="line">m := &amp;Master&#123;&#125;</span><br><span class="line">m.mu = sync.Mutex&#123;&#125;</span><br><span class="line">m.nReduce = nReduce <span class="comment">//输入的参数nReduce（输入的文件会被划分成几个task来处理）</span></span><br><span class="line">m.files = files <span class="comment">//文件名数组</span></span><br><span class="line"><span class="keyword">if</span> nReduce &gt; <span class="built_in">len</span>(files) &#123; <span class="comment">//确定分发task的channel的缓冲区大小</span></span><br><span class="line">m.taskCh = <span class="built_in">make</span>(<span class="keyword">chan</span> Task, nReduce)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.taskCh = <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="built_in">len</span>(m.files)) <span class="comment">//文件数量多于分成的task数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.initMapTask()</span><br><span class="line"><span class="keyword">go</span> m.tickSchedule()</span><br><span class="line">m.server()</span><br><span class="line">DPrintf(<span class="string">"Master init"</span>)</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master结构的定义：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">files      []<span class="keyword">string</span>   <span class="comment">//需要处理的files</span></span><br><span class="line">nReduce    <span class="keyword">int</span>        <span class="comment">//输入的参数nReduce（输入的文件会被划分成几个task来处理）</span></span><br><span class="line">taskPhase  TaskPhase  <span class="comment">//taskPhase（map阶段还是reduce阶段）</span></span><br><span class="line">taskStats  []TaskStat <span class="comment">//taskStats（各个task的状态）</span></span><br><span class="line">taskNum    <span class="keyword">int</span>        <span class="comment">//task数量</span></span><br><span class="line">mu         sync.Mutex <span class="comment">//mu（全局锁）</span></span><br><span class="line">done       <span class="keyword">bool</span>       <span class="comment">//done（任务是否已完成）</span></span><br><span class="line">workerSeq  <span class="keyword">int</span>        <span class="comment">//workerSeq（有几个worker）</span></span><br><span class="line">taskCh     <span class="keyword">chan</span> Task  <span class="comment">//taskCh（用来分发task的channel）</span></span><br><span class="line">finishTask <span class="keyword">int32</span>      <span class="comment">//statCh（用来接受完成task数量）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master包含的本地method有：initMapTask()  taskSchedule()  getTask()  tickSchedule()  initReduceTask()</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">initMapTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">"Init Map Task"</span>)</span><br><span class="line">m.taskPhase = MapPhase <span class="comment">//设置阶段</span></span><br><span class="line">m.taskStats = <span class="built_in">make</span>([]TaskStat, <span class="built_in">len</span>(m.files)) <span class="comment">//创建task状态数组</span></span><br><span class="line">m.taskNum = <span class="built_in">len</span>(m.files) <span class="comment">//task数量</span></span><br><span class="line">m.finishTask = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> m.taskStats &#123;</span><br><span class="line"><span class="keyword">go</span> m.taskSchedule(index) <span class="comment">//对每一个task，创建一个状态机循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单个task的调度，用一个Loop来实现一个状态机。</p><ol><li>如果处在TaskStatusReady状态，则getTask()并放进channel</li><li>如果处在TaskStatusQueue，什么都不做</li><li>如果处在TaskStatusRunning，如果任务超时，则重新getTask()并放进channel</li><li>如果处在TaskStatusFinish，则finishTask自加1</li><li>如果处在TaskStatusErr，则getTask()并放进channel</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">taskSchedule</span><span class="params">(taskSeq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> m.Done() &#123; <span class="comment">//如果Done则结束</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">DPrintf(<span class="string">"Schedule begin, task:%v, Status: %v"</span>, taskSeq, m.taskStats[taskSeq].Status)</span><br><span class="line"><span class="keyword">switch</span> m.taskStats[taskSeq].Status &#123; <span class="comment">//根据处在的不同状态，完成不同的操作</span></span><br><span class="line"><span class="keyword">case</span> TaskStatusReady:</span><br><span class="line">m.taskCh &lt;- m.getTask(taskSeq)</span><br><span class="line">m.taskStats[taskSeq].Status = TaskStatusQueue</span><br><span class="line"><span class="keyword">case</span> TaskStatusQueue:</span><br><span class="line"><span class="keyword">case</span> TaskStatusRunning:</span><br><span class="line"><span class="keyword">if</span> time.Since(m.taskStats[taskSeq].StartTime) &gt; MaxTaskRunTime &#123;</span><br><span class="line">m.taskStats[taskSeq].Status = TaskStatusQueue</span><br><span class="line">m.taskCh &lt;- m.getTask(taskSeq)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> TaskStatusFinish:</span><br><span class="line">m.finishTask += <span class="number">1</span></span><br><span class="line">m.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//单个task完成了就结束</span></span><br><span class="line"><span class="keyword">case</span> TaskStatusErr:</span><br><span class="line">m.taskStats[taskSeq].Status = TaskStatusQueue</span><br><span class="line">m.taskCh &lt;- m.getTask(taskSeq)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Task status err"</span>)</span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">"Schedule end, task:%v, Status: %v"</span>, taskSeq, m.taskStats[taskSeq].Status)</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">time.Sleep(ScheduleInterval) <span class="comment">//睡眠一个间隙</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是getTask()的实现</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">getTask</span><span class="params">(taskSeq <span class="keyword">int</span>)</span> <span class="title">Task</span></span> &#123;</span><br><span class="line">task := Task&#123;</span><br><span class="line">FileName: <span class="string">""</span>,</span><br><span class="line">NReduce:  m.nReduce,</span><br><span class="line">NMaps:    <span class="built_in">len</span>(m.files),</span><br><span class="line">Seq:      taskSeq, <span class="comment">//序号</span></span><br><span class="line">Phase:    m.taskPhase,</span><br><span class="line">Alive:    <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">"Get task, taskseq:%d, len files:%d, len tasks:%d"</span>, m, taskSeq, <span class="built_in">len</span>(m.files), <span class="built_in">len</span>(m.taskStats))</span><br><span class="line"><span class="keyword">if</span> task.Phase == MapPhase &#123;</span><br><span class="line">task.FileName = m.files[taskSeq]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>task的结构体</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">FileName <span class="keyword">string</span></span><br><span class="line">NReduce  <span class="keyword">int</span></span><br><span class="line">NMaps    <span class="keyword">int</span></span><br><span class="line">Seq      <span class="keyword">int</span></span><br><span class="line">Phase    TaskPhase</span><br><span class="line">Alive    <span class="keyword">bool</span> <span class="comment">// worker should exit when alive is false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当map阶段完成，则开始进入reduce阶段。该函数由独立线程执行，以检测当前map状态</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">tickSchedule</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> !m.Done() &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">DPrintf(<span class="string">"Global schedule, finTask:%v, taskNum:%v\n"</span>, m.finishTask, m.taskNum)</span><br><span class="line"><span class="keyword">if</span> m.finishTask == <span class="keyword">int32</span>(m.taskNum) &#123;</span><br><span class="line"><span class="keyword">if</span> m.taskPhase == MapPhase &#123;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">m.initReduceTask()</span><br><span class="line">time.Sleep(ScheduleInterval)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">time.Sleep(ScheduleInterval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initReduceTask()的实现：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">initReduceTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">"Init Reduce Task"</span>)</span><br><span class="line">m.taskPhase = ReducePhase</span><br><span class="line">m.taskStats = <span class="built_in">make</span>([]TaskStat, m.nReduce)</span><br><span class="line">m.taskNum = m.nReduce</span><br><span class="line">m.finishTask = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> m.taskStats &#123;</span><br><span class="line"><span class="keyword">go</span> m.taskSchedule(index) <span class="comment">//和map阶段类似，对每一个task，创建一个状态机循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是server()函数，用来监听Worker的RPC调用</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">rpc.Register(m) <span class="comment">//注册RPC</span></span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line">sockname := masterSock()</span><br><span class="line">os.Remove(sockname)</span><br><span class="line">l, e := net.Listen(<span class="string">"unix"</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>) <span class="comment">//开始监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master其余method均为给Worker调用，在本地RPC框架中注册，包括regTask()  GetOneTask()  ReportTask()  RegWorker()</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> TaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Task *Task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册task，其实就是在Master端记录当前task的状态</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">regTask</span><span class="params">(args *TaskArgs, task *Task)</span></span> &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> task.Phase != m.taskPhase &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Task phase doesn't match"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.taskStats[task.Seq].Status = TaskStatusRunning</span><br><span class="line">m.taskStats[task.Seq].WorkerId = args.WorkerId</span><br><span class="line">m.taskStats[task.Seq].StartTime = time.Now()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从channel中获得一个task，并返回给worker</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GetOneTask</span><span class="params">(args *TaskArgs, reply *TaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">task := &lt;-m.taskCh</span><br><span class="line">reply.Task = &amp;task</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> task.Alive &#123;</span><br><span class="line">m.regTask(args, &amp;task)</span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">"Get one Task, args:%+v, reply:%+v"</span>, args, reply)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报告task的函数，如果完成了，就将task在状态数组中的状态改为Finish，否则改为Error</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReportTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Done     <span class="keyword">bool</span></span><br><span class="line">Seq      <span class="keyword">int</span></span><br><span class="line">Phase    TaskPhase</span><br><span class="line">WorkerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">ReportTask</span><span class="params">(args *ReportTaskArgs, reply *ReportTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">"Get report task: %+v, taskPhase: %+v"</span>, args, m.taskPhase)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> m.taskPhase != args.Phase || args.WorkerId != m.taskStats[args.Seq].WorkerId &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Done &#123;</span><br><span class="line">m.taskStats[args.Seq].Status = TaskStatusFinish</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.taskStats[args.Seq].Status = TaskStatusErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册Worker的函数，Master给各个Worker分配一个序号</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisterArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RegisterReply <span class="keyword">struct</span> &#123;</span><br><span class="line">WorkerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">RegWorker</span><span class="params">(args *RegisterArgs, reply *RegisterReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">m.workerSeq++</span><br><span class="line">reply.WorkerId = m.workerSeq</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="worker-节点"><a class="markdownIt-Anchor" href="#worker-节点"></a> Worker 节点</h3><ul><li>mrworker.go</li></ul><p>mapf和reducef分别为从外部库导入到自定义map函数和reduce函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Usage: mrworker xxx.so\n"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">mapf, reducef := loadPlugin(os.Args[<span class="number">1</span>])</span><br><span class="line">mr.Worker(mapf, reducef)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载自定义的map函数和reduce函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadPlugin</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">mr</span>.<span class="title">KeyValue</span>, <span class="title">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line">p, err := plugin.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot load plugin %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">xmapf, err := p.Lookup(<span class="string">"Map"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot find Map in %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">mapf := xmapf.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">mr</span>.<span class="title">KeyValue</span>)</span></span><br><span class="line">xreducef, err := p.Lookup(<span class="string">"Reduce"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot find Reduce in %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">reducef := xreducef.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mapf, reducef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worker函数，函数参数为map和reduce函数指针</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Worker(mapf func(string, string) []KeyValue,</span><br><span class="line">reducef func(string, []string) string) &#123;</span><br><span class="line"></span><br><span class="line">w :&#x3D; worker&#123;&#125;</span><br><span class="line">w.mapf &#x3D; mapf</span><br><span class="line">w.reducef &#x3D; reducef</span><br><span class="line">w.register()</span><br><span class="line">w.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worker结构体</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">id      <span class="keyword">int</span></span><br><span class="line">mapf    <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span></span></span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将mapf和reducef函数指针进行赋值后，向Master注册自己，其实就是获得一个Master分配的递增id</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">args := &amp;RegisterArgs&#123;&#125;</span><br><span class="line">reply := &amp;RegisterReply&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> ok := call(<span class="string">"Master.RegWorker"</span>, args, reply); !ok &#123;</span><br><span class="line">log.Fatal(<span class="string">"reg fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">w.id = reply.WorkerId</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行run函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// if reqTask conn fail, worker exit</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">t := w.reqTask()</span><br><span class="line"><span class="keyword">if</span> !t.Alive &#123;</span><br><span class="line">DPrintf(<span class="string">"worker %v get task not alive, exit"</span>, w.id)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">"worker %v get task alive"</span>, w.id)</span><br><span class="line">w.doTask(t)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在run函数中，循环请求（reqTask）和处理（doTask）任务</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">reqTask</span><span class="params">()</span> <span class="title">Task</span></span> &#123;</span><br><span class="line">args := TaskArgs&#123;&#125;</span><br><span class="line">args.WorkerId = w.id</span><br><span class="line">reply := TaskReply&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok := call(<span class="string">"Master.GetOneTask"</span>, &amp;args, &amp;reply); !ok &#123;</span><br><span class="line">DPrintf(<span class="string">"worker get task fail,exit"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">DPrintf(<span class="string">"worker get task:%+v"</span>, reply.Task)</span><br><span class="line"><span class="keyword">return</span> *reply.Task <span class="comment">//请求一个任务并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不用阶段，分别doMapTask和doReduceTask，其中分别调用了mapf和reducef，完成或者出错，则调用reportTask向Master进行报告</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">doTask</span><span class="params">(t Task)</span></span> &#123;</span><br><span class="line">DPrintf(<span class="string">"Worker do Task"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> t.Phase &#123;</span><br><span class="line"><span class="keyword">case</span> MapPhase:</span><br><span class="line">w.doMapTask(t)</span><br><span class="line"><span class="keyword">case</span> ReducePhase:</span><br><span class="line">w.doReduceTask(t)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"task phase err: %v"</span>, t.Phase))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是RPC调用过程中call函数的实现，对系统提供的RPC接口进行了封装</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// send an RPC request to the master, wait for the response.</span></span><br><span class="line"><span class="comment">// usually returns true.</span></span><br><span class="line"><span class="comment">// returns false if something goes wrong.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(rpcname <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// c, err := rpc.DialHTTP("tcp", "127.0.0.1"+":1234")</span></span><br><span class="line">sockname := masterSock()</span><br><span class="line">c, err := rpc.DialHTTP(<span class="string">"unix"</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">DPrintf(<span class="string">"dialing:"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">err = c.Call(rpcname, args, reply)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DPrintf(<span class="string">"%+v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Labs </tag>
            
            <tag> 6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[6.824] 分布式笔记</title>
      <link href="/2020/12/06/6.824/distributed-system-notes-1/"/>
      <url>/2020/12/06/6.824/distributed-system-notes-1/</url>
      
        <content type="html"><![CDATA[<h2 id="mit-6824-分布式系统笔记"><a class="markdownIt-Anchor" href="#mit-6824-分布式系统笔记"></a> MIT 6.824 分布式系统笔记</h2><h3 id="l3-gfs"><a class="markdownIt-Anchor" href="#l3-gfs"></a> L3 GFS</h3><h4 id="分布式的难点"><a class="markdownIt-Anchor" href="#分布式的难点"></a> 分布式的难点</h4><p>人们设计大型分布式系统或大型存储系统出发点通常是，他们想获取巨大的性能加成，进而利用数百台计算机的资源来同时完成大量工作。因此，性能问题就成为了最初的诉求。 之后，很自然的想法就是将数据分割放到大量的服务器上，这样就可以并行的从多台服务器读取数据。我们将这种方式称之为分片（Sharding）。</p><p>如果你在成百上千台服务器进行分片，你将会看见常态的故障。如果你有数千台服务器，那么总是会有一台服务器宕机，每天甚至每个小时都可能会发生错误。所以，我们需要自动化的方法而不是人工介入来修复错误。我们需要一个自动的容错系统，这就引出了容错这个话题（fault tolerance）。</p><p>实现容错最有用的一种方法是使用复制，只需要维护2-3个数据的副本，当其中一个故障了，你就可以使用另一个。所以，如果想要容错能力，就得有复制（replication）。</p><p>如果有复制，那就有了两份数据的副本。可以确定的是，如果你不小心，它们就会不一致。所以，你本来设想的是，有了两个数据副本，你可以任意使用其中一个副本来容错。但是如果你不够小心，两个数据的副本就不是完全一致，严格来说，它们就不再互为副本了。而你获取到的数据内容也将取决于你向哪个副本请求数据。这对于应用程序来说就有些麻烦了。所以，如果我们有了复制，我们就有不一致的问题（inconsistency）。</p><p>通过聪明的设计，你可以避免不一致的问题，并且让数据看起来也表现的符合预期。但是为了达到这样的效果，你总是需要额外的工作，需要不同服务器之间通过网络额外的交互，而这样的交互会降低性能。所以如果你想要一致性，你的代价就是低性能。但这明显不是我们最开始所希望的。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201111174832.png" width="500px"> </div><h4 id="一种分布式存储错误的设计"><a class="markdownIt-Anchor" href="#一种分布式存储错误的设计"></a> 一种分布式存储错误的设计</h4><p>对于强一致性或者好的一致性的设备，从应用程序或者客户端来看就像是在和一台服务器在通信。对于一个理想的强一致性模型，你看到的就像是只有一台服务器，一份数据，并且系统一次只做一件事情。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201111211740.png" width="500px"> </div><p>上图表示了一个因服务端接收数据顺序不一样而可能出问题的系统。</p><h4 id="gfs的设计目标"><a class="markdownIt-Anchor" href="#gfs的设计目标"></a> GFS的设计目标</h4><p>GFS的目标是构建一个大型的，快速的文件系统。并且这个文件系统是全局有效的，这样各种不同的应用程序都可以从中读取数据。</p><p>GFS在各个方面对大型的顺序文件读写进行了定制。GFS只会顺序处理，不支持随机访问。</p><h4 id="gfs-master节点"><a class="markdownIt-Anchor" href="#gfs-master节点"></a> GFS Master节点</h4><p>接下来是GFS的大致架构。</p><p>GFS中只有一个Master节点在工作，Master节点保存了文件名和存储位置的对应关系。除此之外，还有大量的Chunk服务器。Master用来管理文件和Chunk的信息，而Chunk服务器用来存储实际的数据。Master节点知道每一个文件对应的Chunk的ID，这些Chunk是64MB大小，它们共同构成了一个文件。如果我有一个1GB的文件，那么Master节点就知道文件的第一个Chunk存储在哪，第二个Chunk存储在哪，等等。当我想读取这个文件中的任意一个部分时，我需要向Master节点查询对应的Chunk在哪个服务器上，之后我可以直接从Chunk服务器读取对应的Chunk数据。</p><p>Master节点内保存的数据内容，主要关心两个表单：</p><ol><li><p>文件名 -&gt; Chunk ID 或者 Chunk Handle数组的对应。这个表单告诉你，文件对应了哪些Chunk</p></li><li><p>Chunk ID -&gt; Chunk 数据 对应关系，包括了：</p><ul><li>每个Chunk存储在哪些服务器上，所以这部分是Chunk服务器的列表</li></ul></li></ol><ul><li>每个Chunk当前的版本号，所以Master节点必须记住每个Chunk对应的版本号。<ul><li>所有对于Chunk的写操作都必须在主Chunk（Primary Chunk）上顺序处理，主Chunk是Chunk的多个副本之一。所以，Master节点必须记住哪个Chunk服务器持有主Chunk。</li></ul></li><li>并且，主Chunk只能在特定的租约时间内担任主Chunk，所以，Master节点要记住主Chunk的租约过期时间</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201111213312.png" width="500px"> </div><p>以上数据都在内存中，如果Master故障了，这些数据就都丢失了。为了能让Master重启而不丢失数据，Master节点会同时将数据存储在磁盘上。Master会在磁盘上存储Log，每次有数据变更时，Master会在磁盘的Log中追加一条记录，并生成CheckPoint（备份点）。</p><ol><li><p>Chunk Handle的数组（第一个表单）要保存在磁盘上。标记为NV（non-volatile 非易失）这个标记的数据会写到磁盘上</p></li><li><p>Chunk服务器列表不用保存到磁盘上。因为Master节点重启之后可以与所有的Chunk服务器通信，并查询每个Chunk服务器存储了哪些Chunk，标记为V（volatile）</p></li><li><p>版本号要不要写入磁盘取决于GFS如何工作，我认为需要写入磁盘。之后讨论，先标记为NV</p></li><li><p>主Chunk的ID，可以确定不用写入磁盘，因为Master节点重启之后会忘记谁是主Chunk，这个时候，Master节点可以安全指定一个新的主Chunk。所以这里标记成V</p></li><li><p>类似的，租约过期时间也不用写入磁盘，标记成V</p></li></ol><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201111215459.png" width="500px"> </div><p>任何时候，如果文件扩展到达了一个新的64MB，需要新增一个Chunk或者由于指定了新的主Chunk而导致版本号更新了，Master节点需要向磁盘中的Log追加一条记录，我刚刚向这个文件添加了一个新的Chunk或者我刚刚修改了Chunk的版本号。</p><blockquote><p>这里在磁盘中维护Log而不是数据库的原因是，数据库本质上来说是某种B树（B-tree）或者Hash table，相比之下，追加Log会非常的高效，因为你可以将最近的多个Log记录一次性的写入磁盘。因为这些数据都是向同一个地址追加，这样只需要等待磁盘的磁碟旋转一次。而对于B树来说，每一份数据都需要在磁盘中随机找个位置写入。所以使用Log可以使得磁盘写入更快一些。</p></blockquote><p>当Master节点故障重启，并重建状态，你不会想要从Log的最开始重建状态，因为Log的最开始可能是很久以前。重启时，Master节点会从Log中的最近一个CheckPoint开始恢复，并逐条执行从CheckPoint开始的Log记录。</p><h4 id="gfs读文件-read-file"><a class="markdownIt-Anchor" href="#gfs读文件-read-file"></a> GFS读文件 Read file</h4><p>有了之前的基础，接下来会列出GFS读和写的步骤，最后，介绍出现故障之后，系统是如何保持正确的行为。</p><p>对于读请求来说，意味着应用或者GFS客户端有一个文件名和它想从文件的某个位置读取的偏移量（offset），应用程序会将这些信息发送给Master节点。Master节点会从自己的File表单中查询文件名，得到Chunk ID的数组。因为每个Chunk都是64MB，所以偏移量除以64MB就可以从数组中得到对应的Chunk ID。之后Master再从Chunk表单中找到存有Chunk的服务器列表，并将列表返回给客户端。所以分两步：</p><ol><li>客户端-&gt; 文件名 + 偏移量 -&gt; Master</li><li>Master-&gt; Chunk handle + 服务器列表 -&gt; 客户端</li></ol><p>现在客户端从服务器列表中挑选一个来读取数据。（论文中说客户端会选择一个网络上最近的服务器）客户端可能会连续多次读取同一个Chunk的不同位置。所以，客户端会缓存Chunk和服务器的对应关系，这样不用向Master一次次去请求相同的信息。</p><p>接下来，客户端和Chunk通信，将Chunk Handle和偏移量发送给那个Chunk服务器。服务器找到数据，将数据返回给客户端。</p><h4 id="gfs写文件-write-file-1"><a class="markdownIt-Anchor" href="#gfs写文件-write-file-1"></a> GFS写文件 Write File 1</h4><p>GFS写文件的过程更加复杂。我们只讨论客户端的记录追加（Record Append），想把buffer中的数据，追加到这个文件名对应的文件中。对于写文件，客户端会向Master节点发送请求说：我想向这个文件名对应的文件追加数据，请告诉我文件中最后一个Chunk的位置。</p><p>当有多个客户端同时写同一个文件时，一个客户端并不能知道文件究竟有多长。这个时候，客户端可以向Master节点查询哪个Chunk服务器保存了文件的最后一个Chunk。对于读文件来说，可以从任何最新的Chunk副本读取数据，但是对于写文件来说，必须要通过Chunk的主副本（Primary Chunk）来写入。对于某个特定的Chunk来说，在某一个时间点，Master不一定指定了Chunk的主副本。所以，写文件的时候，需要考虑Chunk的主副本不存在的情况。</p><p>对于Master节点来说，如果发现Chunk的主副本不存在，Master会找出所有存有Chunk最新副本的Chunk服务器。Master节点的工作就是弄清楚在追加文件时，客户端应该与哪个Chunk服务器进行通信。</p><p>每个Chunk可能同时有多个副本，最新的副本是指，副本中保存的版本号与Master中记录的Chunk的版本号一致。Chunk副本中的版本号是由Master节点下发的，所以Master节点知道，对于一个特定的Chunk，哪个版本号是最新的。所以Chunk的版本号在Master节点上需要保存在磁盘这种非易失的存储中。如果版本号在故障中丢失，这时，Master无法区分Chunk服务器的数据是旧的或者是新的。</p><p>回到之前讲的，当客户端想要对文件进行追加，但是Master又不知道文件尾的Chunk对应的Primary在哪时，Master会等所有存储了最新Chunk版本的服务器集合完成，然后挑选一个作为Primary，其他的作为Secondary。之后，Master会增加版本号，并将版本号写入磁盘，这样就不会丢失这个版本号数据。接下来，Master节点会向Primary和Secondary副本对应的服务器发送消息并告诉它们，谁是Primary，谁是Secondary，Chunk的新版本是什么。Primary和Secondary服务器都会将版本号存储在本地的磁盘中。这样，当它们因为故障重启时，它们可以向Master报告本地保存的Chunk的实际版本号。</p><p>所以，现在我们有了一个Primary，它可以接收来自客户端的请求，并将写请求应用到多个Chunk服务器中。之所以要管理Chunk的版本号，是因为这样Master可以将实际更新Chunk的能力转移给Primary服务器。并且在将版本号更新到Primary和Secondary服务器之后，如果Master节点故障重启，还是可以在相同的Primary和Secondary服务器上继续更新Chunk。</p><p>现在，Master节点通知Primary和Secondary服务器，你们可以修改这个Chunk。它还给Primary一个租约，这个租约告诉Primary说，在接下来的60秒中，你将是Primary，60秒之后你必须停止成为Primary。这种机制可以确保我们不会同时有两个Primary，我们之后会再做讨论（之后的问答中有一个专门的问题讨论）。</p><p>现在来看GFS论文的图2。假设现在Master节点告诉客户端谁是Primary，谁是Secondary，GFS提出了一种聪明的方法来实现写请求的执行序列。客户端会将要追加的数据发送给Primary和Secondary服务器，这些服务器会将数据写入到一个临时位置。所以最开始，这些数据不会追加到文件中。当所有的服务器都返回确认消息说，已经有了要追加的数据，客户端会向Primary服务器发送一条消息说，你和所有的Secondary服务器都有了要追加的数据，现在我想将这个数据追加到这个文件中。Primary服务器或许会从大量客户端收到大量的并发请求，Primary服务器会以某种顺序，一次只执行一个请求。对于每个客户端的追加数据请求（也就是写请求），Primary会查看当前文件结尾的Chunk，并确保Chunk中有足够的剩余空间，然后将客户端要追加的数据写入Chunk的末尾。并且，Primary会通知所有的Secondary服务器也将客户端要追加的数据写入在它们自己存储的Chunk末尾。这样，包括Primary在内的所有副本，都会收到通知将数据追加在Chunk的末尾。</p><p>但是对于Secondary服务器来说，它们可能可以执行成功，也可能会执行失败，比如说磁盘空间不足，比如说故障了，比如说Primary发出的消息网络丢包了。如果Secondary实际真的将数据写入到了本地磁盘存储的Chunk中，它会回复“yes”给Primary。如果所有的Secondary服务器都成功将数据写入，并将“yes”回复给了Primary，并且Primary也收到了这些回复。Primary会向客户端返回写入成功。如果至少一个Secondary服务器没有回复Primary，或者回复了，但是内容却是：抱歉，一些不好的事情发生了，比如说磁盘空间不够，或者磁盘故障了，Primary会向客户端返回写入失败。</p><p>GFS论文说，如果客户端从Primary得到写入失败，那么客户端应该重新发起整个追加过程。客户端首先会重新与Master交互，找到文件末尾的Chunk；之后，客户端需要重新发起对于Primary和Secondary的数据追加操作。</p><h4 id="gfs写文件-write-file-2"><a class="markdownIt-Anchor" href="#gfs写文件-write-file-2"></a> GFS写文件 Write File 2</h4><p>这部分主要是写文件操作的问答</p><blockquote><p>待续</p></blockquote><h4 id="gfs的一致性"><a class="markdownIt-Anchor" href="#gfs的一致性"></a> GFS的一致性</h4><p>这里最重要的部分就是重复我们刚刚讨论过的内容。</p><p>当我们追加数据时，面对Chunk的三个副本，当客户端发送了一个追加数据的请求，要将数据A追加到文件末尾，所有的三个副本，包括一个Primary和两个Secondary，都成功的将数据追加到了Chunk，所以Chunk中的第一个记录是A。</p><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimages%5C%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201114161415.png" alt="微信截图_20201114161415" /></p><p>假设第二个客户端加入进来，想要追加数据B，但是由于网络问题发送给某个副本的消息丢失了。所以，追加数据B的消息只被两个副本收到，一个是Primary，一个是Secondary。这两个副本都在文件中追加了数据B，所以，现在我们有两个副本有数据B，另一个没有。</p><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimages%5C%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201114161458.png" alt="微信截图_20201114161458" /></p><p>之后，第三个客户端想要追加数据C，并且第三个客户端记得下图中左边第一个副本是Primary。Primary选择了偏移量，并将偏移量告诉Secondary，将数据C写在Chunk的这个位置。三个副本都将数据C写在这个位置。</p><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimages%5C%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201114161601.png" alt="微信截图_20201114161601" /></p><p>对于数据B来说，客户端会收到写入失败的回复，客户端会重发写入数据B的请求。所以，第二个客户端会再次请求追加数据B，或许这次数据没有在网络中丢包，并且所有的三个副本都成功追加了数据B。现在三个副本都在线，并且都有最新的版本号。</p><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimages%5C%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201114161638.png" alt="微信截图_20201114161638" /></p><p>之后，如果一个客户端读文件，则读取到的内容取决于读取的是Chunk的哪个副本。客户端总共可以看到三条数据，但是取决于不同的副本，读取数据的顺序是不一样的。</p><p>或许最坏的情况是，一些客户端写文件时，因为其中一个Secondary未能成功执行数据追加操作，客户端从Primary收到写入失败的回复。在客户端重新发送写文件请求之前，客户端就故障了。所以，你有可能进入这种情形：数据D出现在某些副本中，而其他副本则完全没有。</p><p>在GFS的这种工作方式下，如果Primary返回写入成功，那么一切都还好，如果Primary返回写入失败，就不是那么好了。Primary返回写入失败会导致不同的副本有完全不同的数据。</p><blockquote><p>提问：为什么GFS要设计成多个副本不一致？</p><p>Robert教授：不明白GFS设计者为什么这么做。GFS可以设计成多个副本完全精确同步的，在lab2和lab3中设计的系统，其中的副本是同步的。你们也会知道，为了保持同步，你们要使用各种各样的技术。</p></blockquote><p>GFS这样设计的理由是足够的简单，但是同时也给应用程序暴露了一些奇怪的数据。这里希望为应用程序提供一个相对简单的写入接口，但应用程序需要容忍读取数据的乱序。如果应用程序不能容忍乱序，应用程序要么可以通过在文件中写入序列号，这样读取的时候能自己识别顺序。</p><p>最后，让我花一分钟来介绍GFS在它生涯的前5-10年在Google的出色表现，总的来说，它取得了巨大的成功，许多许多Google的应用都使用了它，许多Google的基础架构，例如BigTable和MapReduce是构建在GFS之上，所以GFS在Google内部广泛被应用。它最严重的局限可能在于，它只有一个Master节点，会带来以下问题：</p><ul><li>Master节点必须为每个文件，每个Chunk维护表单，随着GFS的应用越来越多，这意味着涉及的文件也越来越多，最终Master会耗尽内存来存储文件表单。你可以增加内存，但是单台计算机的内存也是有上限的。所以，这是人们遇到的最早的问题。</li><li>除此之外，单个Master节点要承载数千个客户端的请求，而Master节点的CPU每秒只能处理数百个请求，尤其Master还需要将部分数据写入磁盘，很快，客户端数量超过了单个Master的能力。</li><li>另一个问题是，应用程序发现很难处理GFS奇怪的语义（本节最开始介绍的GFS的副本数据的同步，或者可以说不同步）。</li><li>最后一个问题是，从我们读到的GFS论文中，Master节点的故障切换不是自动的。GFS需要人工干预来处理已经永久故障的Master节点，并更换新的服务器，这可能需要几十分钟甚至更长的而时间来处理。对于某些应用程序来说，这个时间太长了。</li></ul><h3 id="l4-primary-backup-replication"><a class="markdownIt-Anchor" href="#l4-primary-backup-replication"></a> L4 Primary-Backup Replication</h3><h4 id="复制-replication"><a class="markdownIt-Anchor" href="#复制-replication"></a> 复制 Replication</h4><p>这节主要讲了关于容错（Fault-Tolerance）和复制（Replication）的内容。</p><p>容错是为了用来提高可用性。当服务出现故障，例如硬件和网路故障，我们仍然想提供服务，这时候就需要用到复制这个工具。但是，复制也不是万能的，复制能解决什么呢？</p><p>复制能解决单台计算机的故障，指单台计算机的fail-stop。例如单纯的停止运行，电源或者网络失效。</p><p>但是复制不能处理软件中的bug和硬件中的缺陷。如果软件或者硬件有bug，那么复制对我们没有任何帮助。</p><p>当然，足够幸运的话，复制也可以处理一些硬件和软件的bug。总的来说，我们还是只能期望复制能处理fail-stop错误。</p><p>另一个关于复制的问题：复制所需的资源消耗是否值得？</p><h4 id="状态转移和复制状态机"><a class="markdownIt-Anchor" href="#状态转移和复制状态机"></a> 状态转移和复制状态机</h4><p>复制有两种方法：<strong>状态转移</strong>（State Transfer）和<strong>复制状态机</strong>（Replicated State Machine），这门课中我们主要介绍后者。</p><p>如果有一个服务器的两个副本，让其保持同步，这样Primary出现故障的时候，Backup有所有的信息，就可以接管服务。状态转移的思想：Primary将自己完整的状态（比如内存中的内容），拷贝并发送给Backup。当Primary故障了，Backup就从保存的最新的状态开始运行。VMware FT没有采用这种方法，因为需要通过网络发送的数据量太多。为了提升效率，只发送上次同步后变更的内容就行了。</p><p>复制状态机基于：我们想复制的大部分的服务或者计算机软件都有一些确定的内部操作，不确定的部分是外部的输入。通常情况下，如果一台计算机没有外部影响，它只是一个接一个的执行指令，每条指令执行的是计算机中内存和寄存器上确定的函数，只有当外部事件干预时，才会发生一些预期外的事。</p><p>所以，复制状态机不会在不同的副本之间发送状态，相应的，它只会从Primary将这些外部事件发送给Backup。通常来说，如果有两台计算机，如果它们从相同的状态开始，并且它们以相同的顺序，在相同的时间，看到了相同的输入，那么它们会一直互为副本，并且一直保持一致。</p><p>状态转移传输的是可能是内存，而复制状态机会将来自客户端的操作或者其他外部事件，从Primary传输到Backup。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201115154354.png" width="500px"> </div><p>人们倾向于使用复制状态机的原因是，通常来说，外部操作或者事件比服务的状态要小。</p><p>有趣的是，或许你已经注意到了，VMware FT论文讨论的都是复制状态机，并且只涉及了单核CPU，目前还不确定文中的方案如何扩展到多核处理器中。在多核的机器中，两个核交互处理指令的行为是不确定的，所以就算Primary和Backup执行相同的指令，在多核的机器中，它们也不一定产生相同的结果。</p><p>回到什么样的状态需要被复制这个话题。VMware FT论文对这个问题有一个非常有趣的回答。它会复制机器的完整状态，这包括了所有的内存，所有的寄存器。这是一个非常详细的复制方案，Primary和Backup，即使在最底层也是完全一样的。对于复制方案来说，这种类型是非常少见的。总的来说，大部分场景都是应用程序级别的复制，就像GFS和其他这门课程中会学习的其他论文一样。</p><p>VMware FT的独特之处在于，它从机器级别实现复制，因此它不关心你在机器上运行什么样的软件，它就是复制底层的寄存器和内存。</p><h4 id="vmware-ft工作原理"><a class="markdownIt-Anchor" href="#vmware-ft工作原理"></a> VMware FT工作原理</h4><p>VMware FT需要两个物理服务器。将Primary和Backup运行在一台服务器的两个虚拟机里面毫无意义，因为容错本来就是为了能够抵御硬件故障。所以，你至少需要两个物理服务器运行VMM，Primary在其中一个物理服务器上，Backup在另一个物理服务器上。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201115161607.png" width="500px"> </div><p>两个物理服务器上的VMM会为每个虚拟机分配一段内存，这两段内存的镜像需要完全一致，或者我们的目的就是让Primary和Backup的内存镜像完全一致。所以现在，我们有两个物理服务器，它们每一个都运行了一个虚拟机，每个虚拟机里面都有我们关心的服务的一个拷贝。我们假设有一个网络连接了这两个物理服务器。</p><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimages%5C%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201115161820.png" alt="微信截图_20201115161820" /></p><p>此外，在这个LAN上，还有一些客户端。所以，基本的工作流程是，我们假设这两个副本，或者说这两个虚拟机：Primary和Backup，互为副本。某些我们服务的客户端，向Primary发送了一个请求，这个请求以网络数据包的形式发出。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201115162121.png" width="500px"> </div><p>这个网络数据包产生一个中断，之后这个中断送到了VMM。VMM可以发现这是一个发给我们的多副本服务的一个输入，所以这里VMM会做两件事情：</p><ul><li>在虚拟机的Guest操作系统中，模拟网络数据包到达的中断，以将相应的数据送给应用程序的Primary副本。</li><li>除此之外，因为这是一个多副本虚拟机的输入，VMM会将网络数据包拷贝一份，并通过网络送给Backup虚机所在的VMM。</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201115162252.png" width="500px"> </div><p>Backup虚机所在的VMM知道这是发送给Backup虚机的网络数据包，它也会在Backup虚机中模拟网络数据包到达的中断，以将数据发送给应用程序的Backup。所以现在，Primary和Backup都有了这个网络数据包，它们有了相同的输入，再加上许多细节，它们将会以相同的方式处理这个输入，并保持同步。</p><p>当然，虚机内的服务会回复客户端的请求。在Primary虚机里面，服务会生成一个回复报文，并通过VMM在虚机内模拟的虚拟网卡发出。之后VMM可以看到这个报文，它会实际的将这个报文发送给客户端。</p><p>另一方面，由于Backup虚机运行了相同顺序的指令，它也会生成一个回复报文给客户端，并将这个报文通过它的VMM模拟出来的虚拟网卡发出。但是它的VMM知道这是Backup虚机，会丢弃这里的回复报文。所以这里，Primary和Backup都看见了相同的输入，但是只有Primary虚机实际生成了回复报文给客户端。</p><p>这里有一个术语，VMware FT论文中将Primary到Backup之间同步的数据流的通道称之为Log Channel。虽然都运行在一个网络上，但是这些从Primary发往Backup的事件被称为Log Channel上的Log Event/Entry。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201115162450.png" width="500px"> </div><p>当Primary因为故障停止运行时，FT（Fault-Tolerance）就开始工作了。从Backup的角度来说，它将不再收到来自于Log Channel上的Log条目。实际中，Backup每秒可以收到很多条Log，其中一个来源就是来自于Primary的定时器中断。每个Primary的定时器中断都会生成一条Log条目并发送给Backup，这些定时器中断每秒大概会有100次。所以，如果Primary虚机还在运行，Backup必然可以期望从Log Channel收到很多消息。如果Primary虚机停止运行了，那么Backup的VMM就会说：天，我都有1秒没有从Log Channel收到任何消息了，Primary一定是挂了或者出什么问题了。当Backup不再从Primary收到消息，VMware FT论文的描述是，Backup虚机会上线（Go Alive）。这意味着，Backup不会再等待来自于Primary的Log Channel的事件，Backup的VMM会让Backup自由执行，而不是受来自于Primary的事件驱动。Backup的VMM会在网络中做一些处理（猜测是发GARP），让后续的客户端请求发往Backup虚机，而不是Primary虚机。同时，Backup的VMM不再会丢弃Backup虚机的输出。当然，它现在已经不再是Backup，而是Primary。所以现在，左边的虚机直接接收输入，直接产生输出。到此为止，Backup虚机接管了服务。</p><p>类似的一个场景，虽然没那么有趣，但是也需要能正确工作。如果Backup虚机停止运行，Primary也需要用一个类似的流程来抛弃Backup，停止向它发送事件，并且表现的就像是一个单点的服务，而不是一个多副本服务一样。所以，只要有一个因为故障停止运行，并且不再产生网络流量时，Primary和Backup中的另一个都可以上线继续工作。</p><h4 id="非确定性事件-non-deterministic-events"><a class="markdownIt-Anchor" href="#非确定性事件-non-deterministic-events"></a> 非确定性事件 Non-Deterministic Events</h4><p>目前为止，我们都假设只要Backup虚机也看到了来自客户端的请求，经过同样的执行过程，那么它就会与Primary保持一致，但是这背后其实有很多很重要的细节。就如其他同学之前指出的一样，其中一个问题是存在非确定性（Non-Deterministic）的事件。虽然通常情况下，代码执行都是直接明了的，但并不是说计算机中每一个指令都是由计算机内存的内容而确定的行为。这一节，我们来看一下不由当前内存直接决定的指令。如果我们不够小心，这些指令在Primary和Backup的运行结果可能会不一样。这些指令就是所谓的非确定性事件。所以，设计者们需要弄明白怎么让这一类事件能在Primary和Backup之间同步。</p><p>非确定性事件可以分成几类:</p><ul><li>客户端的输入。假设有一个来自客户端的输入，这个输入随时可能会送法，所以它是不可预期的。客户端请求何时送达， 会有什么样的内容，并不取决于服务当前的状态。我们讨论的系统专注于通过网络来进行交互，所以这里的系统输入的唯一格式就是网络数据包。所以当我们说输入的时候，我们实际上是指接收到了一个网络数据包。而一个网络数据包对于我们来说有两部分，一个是数据包中的数据，另一个是提示数据包送达了的中断。当网络数据包送达时，通常网卡的DMA（Direct Memory Access）会将网络数据包的内容拷贝到内存，之后触发一个中断。操作系统会在处理指令的过程中消费这个中断。对于Primary和Backup来说，这里的步骤必须看起来是一样的，否则它们在执行指令的时候就会出现不一致。所以，这里的问题是，中断在什么时候，具体在指令流中的哪个位置触发？对于Primary和Backup，最好要在相同的时间，相同的位置触发，否则执行过程就是不一样的，进而会导致它们的状态产生偏差。所以，我们不仅关心网络数据包的内容，还关心中断的时间。</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116163150.png" width="500px"> </div><ul><li>另外，有一些指令在不同的计算机上的行为是不一样的，这一类指令称为怪异指令，比如：<ul><li>随机数生成器</li><li>获取当前时间的指令，在不同时间调用会得到不同的结果</li><li>获取计算机的唯一ID</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116163420.png" width="500px"> </div><ul><li>另外一个常见的非确定事件，在VMware FT论文中没有讨论，就是多CPU的并发。我们现在讨论的都是一个单进程系统，没有多CPU多核这种事情。之所以多核会导致非确定性事件，是因为当服务运行在多CPU上时，指令在不同的CPU上会交织在一起运行，进而产生的指令顺序是不可预期的。所以如果我们在Backup上运行相同的代码，并且代码并行运行在多核CPU上，硬件会使得指令以不同（于Primary）的方式交织在一起，而这会引起不同的运行结果。假设两个核同时向同一份数据请求锁，在Primary上，核1得到了锁；在Backup上，由于细微的时间差别核2得到了锁，那么执行结果极有可能完全不一样，这里其实说的就是（在两个副本上）不同的线程获得了锁。所以，多核是一个巨大的非确定性事件来源，VMware FT论文完全没有讨论它，并且它也不适用与我们这节课的讨论。</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116163754.png" width="500px"> </div><blockquote><p>学生提问：如何确保VMware FT管理的服务只使用单核？<br />Robert教授：服务不能使用多核并行计算。硬件几乎可以肯定是多核并行的，但是这些硬件在VMM之下。在这篇论文中，VMM暴露给运行了Primary和Backup虚机操作系统的硬件是单核的。我猜他们也没有一种简单的方法可以将这里的内容应用到一个多核的虚拟机中。</p></blockquote><p>所有的事件都需要通过Log Channel，从Primary同步到Backup。有关日志条目的格式在论文中没有怎么描述，但是我（Robert教授）猜日志条目中有三样东西：</p><ol><li>事件发生时的指令序号。因为如果要同步中断或者客户端输入数据，最好是Primary和Backup在相同的指令位置看到数据，所以我们需要知道指令序号。这里的指令号是自机器启动以来指令的相对序号，而不是指令在内存中的地址。比如说，我们正在执行第40亿零79条指令。所以日志条目需要有指令序号。对于中断和输入来说，指令序号就是指令或者中断在Primary中执行的位置。对于怪异的指令（Weird instructions），比如说获取当前的时间来说，这个序号就是获取时间这条指令执行的序号。这样，Backup虚机就知道在哪个指令位置让相应的事件发生。</li><li>日志条目的类型，可能是普通的网络数据输入，也可能是怪异指令。</li><li>最后是数据。如果是一个网络数据包，那么数据就是网络数据包的内容。如果是一个怪异指令，数据将会是这些怪异指令在Primary上执行的结果。这样Backup虚机就可以伪造指令，并提供与Primary相同的结果。</li></ol><p>举个例子，Primary和Backup两个虚机内部的guest操作系统需要在模拟的硬件里有一个定时器，能够每秒触发100次中断，这样操作系统才可以通过对这些中断进行计数来跟踪时间。因此，这里的定时器必须在Primary和Backup虚机的完全相同位置产生中断，否则这两个虚机不会以相同的顺序执行指令，进而可能会产生分歧。所以，在运行了Primary虚机的物理服务器上，有一个定时器，这个定时器会计时，生成定时器中断并发送给VMM。在适当的时候，VMM会停止Primary虚机的指令执行，并记下当前的指令序号，然后在指令序号的位置插入伪造的模拟定时器中断，并恢复Primary虚机的运行。之后，VMM将指令序号和定时器中断再发送给Backup虚机。虽然Backup虚机的VMM也可以从自己的物理定时器接收中断，但是它并没有将这些物理定时器中断传递给Backup虚机的guest操作系统，而是直接忽略它们。当来自于Primary虚机的Log条目到达时，Backup虚机的VMM配合特殊的CPU特性支持，会使得物理服务器在相同的指令序号处产生一个定时器中断，之后VMM获取到这个中断，并伪造一个假的定时器中断，并将其送入Backup虚机的guest操作系统，并且这个定时器中断会出现在与Primary相同的指令序号位置。</p><blockquote><p>学生提问：这里的操作依赖硬件的定制吗？（实际上我听不清，猜的）<br />Robert教授：是的，这里依赖于CPU的一些特殊的定制，这样VMM就可以告诉CPU，执行1000条指令之后暂停一下，方便VMM将伪造的中断注入，这样Backup虚机就可以与Primary虚机在相同的指令位置触发相同的中断，执行相同的指令。之后，VMM会告诉CPU恢复执行。这里需要一些特殊的硬件，但是现在看起来所有的Intel芯片上都有这个功能，所以也不是那么的特殊。或许15年前，这个功能还是比较新鲜的，但是现在来说就比较正常了。现在这个功能还有很多其他用途，比如说做CPU时间性能分析，可以让处理器每1000条指令中断一次，这里用的是相同的硬件让微处理器每1000条指令产生一个中断。所以现在，这是CPU中非常常见的一个小工具。<br />学生提问：如果Backup领先了Primary会怎么样？<br />Robert教授： 场景可能是这样，Primary即将在第100万条指令处中断，但是Backup已经执行了100万零1条指令了。如果我们让这种场景发生，那么Primary的中断传输就太晚了。如果我们允许Backup执行领先Primary，就会使得中断在Backup中执行位置落后于Primary。所以我们不能允许这种情况发生，我们不能允许Backup在执行指令时领先于Primary。<br />VMware FT是这么做的。它会维护一个来自于Primary的Log条目的等待缓冲区，如果缓冲区为空，Backup是不允许执行指令的。如果缓冲区不为空，那么它可以根据Log的信息知道Primary对应的指令序号，并且会强制Backup虚机最多执行指令到这个位置。所以，Backup虚机的CPU总是会被通知执行到特定的位置就停止。Backup虚机只有在Log缓冲区中有数据才会执行，并且只会执行到Log条目对应的指令序号。在Primary产生的第一个Log，并且送达Backup之前，Backup甚至都不能执行指令，所以Backup总是落后于Primary至少一个Log。如果物理服务器的资源占用过多，导致Backup执行变慢，那么Backup可能落后于Primary多个Log条目。</p></blockquote><p>网络数据包送达时，有一个细节会比较复杂。当网络数据包到达网卡时，如果我们没有运行虚拟机，网卡会将网络数据包通过DMA的方式送到计算机的关联内存中。现在我们有了虚拟机，并且这个网络数据包是发送给虚拟机的，在虚拟机内的操作系统可能会监听DMA并将数据拷贝到虚拟机的内存中。因为VMware的虚拟机设计成可以支持任何操作系统，我们并不知道网络数据包到达时操作系统会执行什么样的操作，有的操作系统或许会真的监听网络数据包拷贝到内存的操作。</p><p>我们不能允许这种情况发生。如果我们允许网卡直接将网络数据包DMA到Primary虚机中，我们就失去了对于Primary虚机的时序控制，因为我们也不知道什么时候Primary会收到网络数据包。所以，实际中，物理服务器的网卡会将网络数据包拷贝给VMM的内存，之后，网卡中断会送给VMM，并说，一个网络数据包送达了。这时，VMM会暂停Primary虚机，记住当前的指令序号，将整个网络数据包拷贝给Primary虚机的内存，之后模拟一个网卡中断发送给Primary虚机。同时，将网络数据包和指令序号发送给Backup。Backup虚机的VMM也会在对应的指令序号暂停Backup虚机，将网络数据包拷贝给Backup虚机，之后在相同的指令序号位置模拟一个网卡中断发送给Backup虚机。这就是论文中介绍的Bounce Buffer机制。</p><h4 id="输出控制-output-rule"><a class="markdownIt-Anchor" href="#输出控制-output-rule"></a> 输出控制 Output Rule</h4><p>对于VMware FT系统的输出，也是值得说一下的。在这个系统中，唯一的输出就是对于客户端请求的响应。客户端通过网络数据包将数据送入，服务器的回复也会以网络数据包的形式送出。我之前说过，Primary和Backup虚机都会生成回复报文，之后通过模拟的网卡送出，但是<strong>只有Primary虚机才会真正的将回复送出</strong>，而Backup虚机只是将回复简单的<strong>丢弃</strong>掉。</p><p>好吧，真实情况会复杂一些。假设我们正在跑一个简单的数据库服务器，这个服务器支持一个计数器自增操作，工作模式是这样，客户端发送了一个自增的请求，服务器端对计数器加1，并返回新的数值。假设最开始一切正常，在Primary和Backup中的计数器都存了10。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116201227.png" width="500px"> </div><p>现在，局域网的一个客户端发送了一个自增的请求给Primary。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116201309.png" width="500px"> </div><p>这个请求在Primary虚机的软件中执行，Primary会发现，现在的数据是10，我要将它变成11，并回复客户端说，现在的数值是11。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116201348.png" width="500px"> </div><p>这个请求也会发送给Backup虚机，并将它的数值从10改到11。Backup也会产生一个回复，但是这个回复会被<strong>丢弃</strong>，这是我们期望发生的。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116201418.png" width="500px"> </div><p>但是，你需要考虑，如果在一个不恰当的时间，出现了故障会怎样？在这门课程中，你需要始终考虑，故障的最坏场景是什么，故障会导致什么结果？在这个例子中，假设Primary确实生成了回复给客户端，但是之后立马崩溃了。更糟糕的是，现在网络不可靠，Primary发送给Backup的Log条目在Primary崩溃时也丢包了。那么现在的状态是，客户端收到了回复说现在的数据是11，但是Backup虚机因为没有看到客户端请求，所以它保存的数据还是10。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116201524.png" width="500px"> </div><p>现在，因为察觉到Primary崩溃了，Backup接管服务。这时，客户端再次发送一个自增的请求，这个请求发送到了原来的Backup虚机，它会将自身的数值从10增加到11，并产生第二个数据是11的回复给客户端。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116201559.png" width="500px"> </div><p>如果客户端比较前后两次的回复，会发现一个明显不可能的场景（两次自增的结果都是11）。</p><p>因为VMware FT的优势就是在不修改软件，甚至软件都不需要知道复制的存在的前提下，就能支持容错，所以我们也不能修改客户端让它知道因为容错导致的副本切换触发了一些奇怪的事情。在VMware FT场景里，我们没有修改客户端这个选项，因为整个系统只有在不修改服务软件的前提下才有意义。所以，前面的例子是个大问题，我们不能让它实际发生。有人还记得论文里面是如何防止它发生的吗？</p><p>论文里的解决方法就是控制输出（Output Rule）。直到Backup虚机确认收到了相应的Log条目，Primary虚机不允许生成任何输出。让我们回到Primary崩溃前，并且计数器的内容还是10，Primary上的正确的流程是这样的：</p><ol><li>客户端输入到达Primary。</li><li>Primary的VMM将输入的拷贝发送给Backup虚机的VMM。所以有关输入的Log条目在Primary虚机生成输出之前，就发往了Backup。之后，这条Log条目通过网络发往Backup，但是过程中有可能丢失。</li><li>Primary的VMM将输入发送给Primary虚机，Primary虚机生成了输出。现在Primary虚机的里的数据已经变成了11，生成的输出也包含了11。但是VMM不会无条件转发这个输出给客户端。</li><li>Primary的VMM会等到之前的Log条目都被Backup虚机确认收到了才将输出转发给客户端。所以，包含了客户端输入的Log条目，会从Primary的VMM送到Backup的VMM，Backup的VMM不用等到Backup虚机实际执行这个输入，就会发送一个表明收到了这条Log的ACK报文给Primary的VMM。当Primary的VMM收到了这个ACK，才会将Primary虚机生成的输出转发到网络中。</li></ol><p>所以，这里的核心思想是，确保在客户端看到对于请求的响应时，Backup虚机一定也看到了对应的请求，或者说至少在Backup的VMM中缓存了这个请求。这样，我们就不会陷入到这个奇怪的场景：客户端已经收到了回复，但是因为有故障发生和副本切换，新接手的副本完全不知道客户端之前收到了对应的回复。</p><p>如果在上面的步骤2中，Log条目通过网络发送给Backup虚机时丢失了，然后Primary虚机崩溃了。因为Log条目丢失了， 所以Backup节点也不会发送ACK消息。所以，如果Log条目的丢失与Primary的崩溃同一时间发生，那么Primary必然在VMM将回复转发到网络之前就崩溃了，所以客户端也就不会收到任何回复，所以客户端就不会观察到任何异常。这就是输出控制（Output rule）。</p><p>所以，Primary会等到Backup已经有了最新的数据，才会将回复返回给客户端。这几乎是所有的复制方案中对于性能产生伤害的地方。这里的同步等待使得Primary不能超前Backup太多，因为如果Primary超前了并且又故障了，对应的就是Backup的状态落后于客户端的状态。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/6.824/20201116201957.png" width="500px"> </div><p>所以，几乎每一个复制系统都有这个问题，在某个时间点，Primary必须要停下来等待Backup，这对于性能是实打实的限制。即使副本机器在相邻的机架上，Primary节点发送消息并收到回复仍然需要0.5毫秒的延时。如果我们想要能承受类似于地震或者城市范围内的断电等问题，Primary和Backup需要在不同的城市，之间可能有5毫秒的差距。如果我们将两个副本放置在不同的城市，每次生成一个输出时，都需要至少等待5毫秒，等Backup确认收到了前一个Log条目，然后VMM才能将输出发送到网络。对于一些低请求量的服务，这不是问题。但是如果我们的服务要能够每秒处理数百万个请求，那就会对我们的性能产生巨大的伤害。</p><p>所以如果条件允许，人们会更喜欢使用在更高层级做复制的系统（详见4.2 最后两段）。这样的复制系统可以理解操作的含义，这样的话Primary虚机就不必在每个网络数据包暂停同步一下，而是可以在一个更高层级的操作层面暂停来做同步，甚至可以对一些只读操作不做暂停。但是这就需要一些特殊的应用程序层面的复制机制。</p><blockquote><p>学生提问：其实不用暂停Primary虚机的执行，只需要阻止Primary虚机的输出就行吧？<br />Robert教授：你是对的。所以，这里的同步等待或许没有那么糟糕。但是不管怎么样，在一个系统中，本来可以几微秒响应一个客户端请求，而现在我们需要先更新另一个城市的副本，这可能会将一个10微秒的操作变成10毫秒。<br />学生提问：这里虽然等待时间比较长，如果提高请求的并发度，是不是还是可以有高性能？<br />Robert教授：如果你有大量的客户端并发的发送请求，那么你或许还是可以在高延时的情况下获得高的吞吐量，但是就需要你有足够聪明的设计和足够的幸运。<br />学生提问：可以不可以将Log保留在Primary虚机对应的物理服务器内存中，这样就不用长时间的等待了。<br />Robert教授：这是一个很好的想法。但是如果你这么做的话，物理服务器宕机，Log就丢失了。通常，如果服务器故障，就认为服务器中的所有数据都没了，其中包括内存的内容。如果故障是某人不小心将服务器的电源拔了，即使Primary对应的物理服务器有电池供电的RAM，Backup也没办法从其获取Log。实际上，系统会在Backup的内存中记录Log。为了保证系统的可靠性，Primary必须等待Backup的ACK才真正输出。你这里的想法很好，但是我们还是不能使用Primary的内存来存Log。<br />学生提问：能不能输入送到Primary，输出从Backup送出？<br />Robert教授：这是个很聪明的想法。我之前完全没有想到过这点。它或许可以工作，我不确定，但是这很有意思。</p></blockquote><h4 id="重复输出-duplicated-output"><a class="markdownIt-Anchor" href="#重复输出-duplicated-output"></a> 重复输出 Duplicated Output</h4><p>还有一种可能的情况是，回复报文已经从VMM发往客户端了，所以客户端收到了回复，但是这时Primary虚机崩溃了。而在Backup侧，客户端请求还堆积在Backup对应的VMM的Log等待缓冲区（详见4.4倒数第二个学生提问），也就是说客户端请求还没有真正发送到Backup虚机中。当Primary崩溃之后，Backup接管服务，Backup首先需要消费所有在等待缓冲区中的Log，以保持与Primay在相同的状态，这样Backup才能以与Primary相同的状态接管服务。假设最后一条Log条目对应来自客户端的请求，那么Backup会在处理完客户端请求对应的中断之后，再上线接管服务。这意味着，Backup会将自己的计数器增加到11（原来是10，处理完客户端的自增请求变成11），并生成一个输出报文。因为这时，Backup已经上线接管服务，它生成的输出报文会被它的VMM发往客户端。这样客户端会收到两个内容是11的回复。如果这里的情况真的发生了，那么明显这也是一个异常行为，因为不可能在运行在单个服务器的服务上发生这种行为。</p><p>好消息是，几乎可以肯定，客户端通过TCP与服务进行交互，也就是说客户端请求和回复都通过TCP Channel收发。当Backup接管服务时，因为它的状态与Primary相同，所以它知道TCP连接的状态和TCP传输的序列号。当Backup生成回复报文时，这个报文的TCP序列号与之前Primary生成报文的TCP序列号是一样的，这样客户端的TCP栈会发现这是一个重复的报文，它会在TCP层面丢弃这个重复的报文，用户层的软件永远也看不到这里的重复。</p><p>这里可以认为是异常的场景，并且被意外的解决了。但是事实上，对于任何有主从切换的复制系统，基本上不可能将系统设计成不产生重复输出。为了避免重复输出，有一个选项是在两边都不生成输出，但这是一个非常糟糕的做法（因为对于客户端来说就是一次失败的请求）。当出现主从切换时，切换的两边都有可能生成重复的输出，这意味着，某种程度上来说，所有复制系统的客户端需要一种重复检测机制。这里我们使用的是TCP来完成重复检测，如果我们没有TCP，那就需要另一种其他机制，或许是应用程序级别的序列号。</p><p>在lab2和lab3中，基本上可以看到我们前面介绍的所有内容，例如输出控制，你会设计你的复制状态机。</p><blockquote><p>学生提问：太长了，听不太清，直接看回答吧。<br />Robert教授：第一部分是对的。当Backup虚机消费了最后一条Log条目，这条Log包含了客户端的请求，并且Backup上线了。从这个时间点开始，我们不需要复制任何东西，因为Primary已经挂了，现在没有任何其他副本。<br />如果Primary向客户端发送了一个回复报文，之后，Primary或者客户端关闭了TCP连接，所以现在客户端侧是没有TCP连接的。Primary挂了之后，Backup虚机还是有TCP连接的信息。Backup执行最后一条Log，Backup会生成一个回复报文，但是这个报文送到客户端时，客户端并没有相应的TCP连接信息。客户端会直接丢弃报文，就像这个报文不存在一样。哦不！这里客户端实际会发送一个TCP Reset，这是一个类似于TCP error的东西给Backup虚机，Backup会处理这里的TCP Reset，但是没关系，因为现在只有一个副本，Backup可以任意处理，而不用担心与其他副本有差异。实际上，Backup会直接忽略这个报文。现在Backup上线了，在这个复制系统里面，它不受任何人任何事的限制。<br />学生提问：Backup接手服务之后，对于之前的TCP连接，还能用相同的TCP源端口来发送数据吗（因为源端口一般是随机的）？<br />Robert教授：你可以这么认为。因为Backup的内存镜像与Primary的完全一致，所以它们会以相同的TCP源端口来发送数据，它们在每一件事情上都是一样的。它们发送的报文每一bit都是一样的。<br />学生提问：甚至对于IP地址都会是一样的吗，毕竟这里涉及两个物理服务器？<br />Robert教授：在这个层面，物理服务器并没有IP地址。在我们的例子中，Primary虚机和Backup虚机都有IP地址，但是物理服务器和VMM在网络上基本是透明的。物理服务器上的VMM在网络上并没有自己的唯一标识。虚拟机有自己独立的操作系统和独立的TCP栈，但是对于IP地址和其他的关联数据，Primary和Backup是一样的（类似于HA VIP）。当虚机发送一个网络报文，它会以虚机的IP地址和MAC地址来发送，这些信息是直接透传到局域网的，而这正是我们想要的。所以Backup会生成与Primary完全一样的报文。这里有一些tricky，因为如果物理服务器都接在一个以太网交换机上，那么它们必然在交换机的不同端口上，在发生切换时，我们希望以太网交换机能够知道当前主节点在哪，这样才能正常的转发报文，这会有一些额外的有意思的事情。大部分时候，Primary和Backup都是生成相同的报文，并送出。<br />（注：早期的VMware虚机都是直接以VLAN或者Flat形式，通过DVS接入到物理网络，所以虚拟机的报文与物理机无关，可以直接在局域网发送。以太网交换机会维护MAC地址表，表明MAC地址与交换机端口的对应，因为Primary和Backup虚机的MAC地址一样，当主从切换时，这个表需要更新，这样同一个目的MAC地址，切换前是发往了Primary虚机所在的物理服务器对应的交换机端口，切换之后是发往了Backup虚机所在的物理服务器对应的交换机端口。交换机MAC地址表的切换通常通过虚机主动发起GARP来更新。）</p></blockquote><h4 id="test-and-set-服务"><a class="markdownIt-Anchor" href="#test-and-set-服务"></a> Test-and-Set 服务</h4><p>最后还有一个细节。我一直都假设Primary出现的是fail-stop故障（详见4.1最开始），但是这不是所有的情况。一个非常常见的场景就是，Primary和Backup都在运行，但是它们之间的网络出现了问题，同时它们各自又能够与一些客户端通信。这时，它们都会以为对方挂了，自己需要上线并接管服务。所以现在，我们对于同一个服务，有两个机器是在线的。因为现在它们都不向彼此发送Log条目，它们自然就出现了分歧。它们或许会因为接收了不同的客户端请求，而变得不一样。</p><p>因为涉及到了计算机网络，那就可能出现上面的问题，而不仅仅是机器故障。如果我们同时让Primary和Backup都在线，那么我们现在就有了脑裂（Split Brain）。这篇论文解决这个问题的方法是，向一个外部的第三方权威机构求证，来决定Primary还是Backup允许上线。这里的第三方就是Test-and-Set服务。</p><p>Test-and-Set服务不运行在Primary和Backup的物理服务器上，VMware FT需要通过网络支持Test-and-Set服务。这个服务会在内存中保留一些标志位，当你向它发送一个Test-and-Set请求，它会设置标志位，并且返回旧的值。Primary和Backup都需要获取Test-and-Set标志位，这有点像一个锁。为了能够上线，它们或许会同时发送一个Test-and-Set请求，给Test-and-Set服务。当第一个请求送达时，Test-and-Set服务会说，这个标志位之前是0，现在是1。第二个请求送达时，Test-and-Set服务会说，标志位已经是1了，你不允许成为Primary。对于这个Test-and-Set服务，我们可以认为运行在单台服务器。当网络出现故障，并且两个副本都认为对方已经挂了时，Test-and-Set服务就是一个仲裁官，决定了两个副本中哪一个应该上线。</p><p>对于这种机制有什么问题吗？</p><blockquote><p>学生提问：只有在网络故障的时候才需要询问Test-and-Set服务吗？<br />Robert教授：即使没有网络分区，在所有情况下，两个副本中任意一个觉得对方挂了，哪怕对方真的挂了，想要上线的那个副本仍然需要获得Test-and-Set服务的锁。在6.824这门课程中，有个核心的规则就是，你无法判断另一个计算机是否真的挂了，你所知道的就是，你无法从那台计算机收到网络报文，你无法判断是因为那台计算机挂了，还是因为网络出问题了导致的。所以，Backup看到的是，我收不到来自Primary的网络报文，或许Primary挂了，或许还活着。Primary或许也同时看不到Backup的报文。所以，如果存在网络分区，那么必然要询问Test-and-Set服务。但是实际上没人知道现在是不是网络分区，所以每次涉及到主从切换，都需要向Test-and-Set服务进行查询。所以，当副本想要上线的时候，Test-and-Set服务必须要在线，因为副本需要获取这里的Test-and-Set锁。现在Test-and-Set看起来像是个单点故障（Single-Point-of-Failure）。虽然VMware FT尝试构建一个复制的容错的系统，但是最后，主从切换还是依赖于Test-and-Set服务在线，这有点让人失望。我强烈的认为，Test-and-Set服务本身也是个复制的服务，并且是容错的。几乎可以肯定的是，VMware非常乐意向你售卖价值百万的高可用存储系统，系统内使用大量的复制服务。因为这里用到了Test-and-Set服务，我猜它也是复制的。</p></blockquote><p>你们将要在Lab2和Lab3构建的系统，会帮助你们构建容错的Test-and-Set服务，所以这个问题可以轻易被解决。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++/timefd</title>
      <link href="/2020/11/09/C++/timefd/"/>
      <url>/2020/11/09/C++/timefd/</url>
      
        <content type="html"><![CDATA[<p>title: ‘[C++] Timefd’<br />date: 2020-12-6 17:03<br />tags:</p><ul><li>timefd<br />categories:</li><li>C++</li></ul><h2 id="timefd"><a class="markdownIt-Anchor" href="#timefd"></a> timefd</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;      /* Definition of PRIu64 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;        /* Definition of uint64_t */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> handle_error(msg) \</span></span><br><span class="line">        <span class="keyword">do</span> &#123; perror(msg); <span class="built_in">exit</span>(EXIT_FAILURE); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">print_elapsed_time(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">curr</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> first_call = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> secs, nsecs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first_call) &#123;</span><br><span class="line">        first_call = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (clock_gettime(CLOCK_MONOTONIC, &amp;start) == <span class="number">-1</span>)</span><br><span class="line">            handle_error(<span class="string">"clock_gettime"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(CLOCK_MONOTONIC, &amp;curr) == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">"clock_gettime"</span>);</span><br><span class="line"></span><br><span class="line">    secs = curr.tv_sec - start.tv_sec;</span><br><span class="line">    nsecs = curr.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (nsecs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        secs--;</span><br><span class="line">        nsecs += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d.%03d: "</span>, secs, (nsecs + <span class="number">500000</span>) / <span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">new_value</span>;</span></span><br><span class="line">    <span class="keyword">int</span> max_exp, fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="built_in">exp</span>, tot_exp;</span><br><span class="line">    <span class="keyword">ssize_t</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((argc != <span class="number">2</span>) &amp;&amp; (argc != <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s init-secs [interval-secs max-exp]\n"</span>,</span><br><span class="line">                argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(CLOCK_REALTIME, &amp;now) == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">"clock_gettime"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a CLOCK_REALTIME absolute timer with initial</span></span><br><span class="line"><span class="comment">        expiration and interval as specified in command line */</span></span><br><span class="line"></span><br><span class="line">    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    new_value.it_value.tv_nsec = now.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">        new_value.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">        max_exp = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        new_value.it_interval.tv_sec = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">        max_exp = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    new_value.it_interval.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fd = timerfd_create(CLOCK_REALTIME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">"timerfd_create"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timerfd_settime(fd, TFD_TIMER_ABSTIME, &amp;new_value, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">"timerfd_settime"</span>);</span><br><span class="line"></span><br><span class="line">    print_elapsed_time();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"timer started\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tot_exp = <span class="number">0</span>; tot_exp &lt; max_exp;) &#123;</span><br><span class="line">        s = <span class="built_in">read</span>(fd, &amp;<span class="built_in">exp</span>, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>))</span><br><span class="line">            handle_error(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">        tot_exp += <span class="built_in">exp</span>;</span><br><span class="line">        print_elapsed_time();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read: %"</span> PRIu64 <span class="string">"; total=%"</span> PRIu64 <span class="string">"\n"</span>, <span class="built_in">exp</span>, tot_exp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++/condition_variable</title>
      <link href="/2020/11/07/C++/condition_variable/"/>
      <url>/2020/11/07/C++/condition_variable/</url>
      
        <content type="html"><![CDATA[<p>title: ‘[C++] Condition_variable’<br />date: 2020-12-6 17:01<br />tags:</p><ul><li>condition_variable</li><li>mutex<br />categories:</li><li>C++</li></ul><h2 id="condition_variable"><a class="markdownIt-Anchor" href="#condition_variable"></a> Condition_variable</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;                // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;                // std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;    // std::condition_variable</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex mtx; <span class="comment">// 全局互斥锁.</span></span><br><span class="line"><span class="built_in">std</span>::condition_variable cv; <span class="comment">// 全局条件变量.</span></span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">ready</span> = <span class="literal">false</span>; <span class="comment">// 全局标志位.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print_id</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">ready</span>) <span class="comment">// 如果标志位不为 true, 则等待...</span></span><br><span class="line">cv.wait(lck); <span class="comment">// 当前线程被阻塞, 当全局标志位变为 true 之后,</span></span><br><span class="line"><span class="comment">// 线程被唤醒, 继续往下执行打印线程编号id.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread "</span> &lt;&lt; id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line"><span class="built_in">ready</span> = <span class="literal">true</span>; <span class="comment">// 设置全局标志位为 true.</span></span><br><span class="line">cv.notify_all(); <span class="comment">// 唤醒所有线程.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// spawn 10 threads:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">threads[i] = <span class="built_in">std</span>::thread(do_print_id, i);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"10 threads ready to race...\n"</span>;</span><br><span class="line">go(); <span class="comment">// go!</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads)</span><br><span class="line">th.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>notify_one</li><li>notify_all</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++/eventfd</title>
      <link href="/2020/11/06/C++/eventfd/"/>
      <url>/2020/11/06/C++/eventfd/</url>
      
        <content type="html"><![CDATA[<p>title: ‘[C++] Eventfd &amp; Epoll’<br />date: 2020-12-6 17:02<br />tags:</p><ul><li>eventfd</li><li>epoll<br />categories:</li><li>C++</li></ul><h2 id="eventfd-epoll"><a class="markdownIt-Anchor" href="#eventfd-epoll"></a> eventfd &amp; epoll</h2><p>实现跨线程的唤醒。一个线程往fd中写入uint64_t的数据唤醒另一个epoll_wait上的线程</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_efd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createEventfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> evtfd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"createEventfd() fd : "</span> &lt;&lt; evtfd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (evtfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed in eventfd\n"</span>;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> evtfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(timeout &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    timeout++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">ssize_t</span> n = <span class="built_in">write</span>(s_efd, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">  <span class="keyword">if</span>(n != <span class="keyword">sizeof</span> one)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" writes "</span> &lt;&lt; n &lt;&lt; <span class="string">" bytes instead of 8\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  s_efd = createEventfd();</span><br><span class="line"></span><br><span class="line">  fd_set rdset;</span><br><span class="line">  FD_ZERO(&amp;rdset);</span><br><span class="line">  FD_SET(s_efd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">  timeout.tv_sec = <span class="number">0</span>;</span><br><span class="line">  timeout.tv_usec = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(testThread)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(select(s_efd + <span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"tick!!!!\n"</span>;</span><br><span class="line">      timeout.tv_sec = <span class="number">0</span>;</span><br><span class="line">      timeout.tv_usec = <span class="number">500000</span>;</span><br><span class="line">      FD_SET(s_efd, &amp;rdset);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> n = <span class="built_in">read</span>(s_efd, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" read "</span> &lt;&lt; n &lt;&lt; <span class="string">" bytes instead of 8\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" wakeup ！\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t.join();</span><br><span class="line">  <span class="built_in">close</span>(s_efd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>net-programing/Linux-API</title>
      <link href="/2020/11/06/net-programing/Linux-API/"/>
      <url>/2020/11/06/net-programing/Linux-API/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-常用网络api"><a class="markdownIt-Anchor" href="#linux-常用网络api"></a> Linux 常用网络API</h2><h4 id="ipv4-专用socket地址结构体"><a class="markdownIt-Anchor" href="#ipv4-专用socket地址结构体"></a> IPv4 专用socket地址结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;     <span class="comment">/* 地址族：AF_INET */</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;         <span class="comment">/* 端口号，要用网络字节序表示 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IPv4地址结构体，见下面 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> s_addr;           <span class="comment">/* IPv4地址，要用网络字节序表示 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr</p><h4 id="创建socket"><a class="markdownIt-Anchor" href="#创建socket"></a> 创建socket</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>domain：底层协议簇<ul><li>PF_INET (Protocol Family of Internet，用于IPv4)</li><li>PF_INET6 (用于IPv6)</li></ul></li><li>type：服务类型<ul><li>SOCK_STREAM 流服务</li><li>SOCK_UGRAM 数据报</li></ul></li><li>protocol：一般0</li><li>成功返回0，失败返回-1并设置errno</li></ul><h4 id="命名socket"><a class="markdownIt-Anchor" href="#命名socket"></a> 命名socket</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>成功返回0，失败返回-1并设置errno。两种常见的errno是EACCES（被绑定的地址是受保护的地址，仅超级用户能够访问，如普通用户绑定到知名服务端口）；EADDRINUSE（被绑定的地址正在使用中）</p><h4 id="监听socket"><a class="markdownIt-Anchor" href="#监听socket"></a> 监听socket</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>backlog参数提示内核监听队列的最大长度。监听的队列的长度超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息</p><p>成功返回0，失败返回-1并设置errno</p><h4 id="接受连接"><a class="markdownIt-Anchor" href="#接受连接"></a> 接受连接</h4><p>从监听队列中接受一个连接：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>成功返回一个新的连接socket，用于通信。失败返回-1并设置errno</p><h4 id="发起连接"><a class="markdownIt-Anchor" href="#发起连接"></a> 发起连接</h4><p>客户端主动与服务器建立连接：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>成功返回0，并可通过sockfd进行通信，失败返回-1并设置errno。两种常见的errno是ECONNREFUSED（目标端口不存在）；ETIMEDOUT（连接超时）</p><h4 id="关闭连接"><a class="markdownIt-Anchor" href="#关闭连接"></a> 关闭连接</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="tcp数据读写"><a class="markdownIt-Anchor" href="#tcp数据读写"></a> TCP数据读写</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>recv读取sockfd上的数据，成功时返回实际读取到数据的长度，可能小于我们期望的长度len，失败返回-1并设置errno</p><p>send往sockfd上写入数据，成功时返回实际写入的数据的长度，失败返回-1并设置errno</p><p>flag参数为数据收发提供额外控制</p><h4 id="地址信息函数"><a class="markdownIt-Anchor" href="#地址信息函数"></a> 地址信息函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure><p>getsockname获取sockfd对应的本端socket地址</p><p>getpeername获取sockfd对应的远端socket地址</p><h4 id="getaddrinfo-getnameinfo"><a class="markdownIt-Anchor" href="#getaddrinfo-getnameinfo"></a> getaddrinfo &amp; getnameinfo</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************** </span></span><br><span class="line"><span class="comment"> * Client/server helper functions</span></span><br><span class="line"><span class="comment"> ********************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * open_clientfd - Open connection to server at &lt;hostname, port&gt; and</span></span><br><span class="line"><span class="comment"> *     return a socket descriptor ready for reading and writing. This</span></span><br><span class="line"><span class="comment"> *     function is reentrant and protocol-independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     On error, returns: </span></span><br><span class="line"><span class="comment"> *       -2 for getaddrinfo error</span></span><br><span class="line"><span class="comment"> *       -1 with errno set for other errors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin open_clientfd */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd, rc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;  <span class="comment">/* Open a connection */</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV;  <span class="comment">/* ... using a numeric port arg. */</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG;  <span class="comment">/* Recommended for connections */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(hostname, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"getaddrinfo failed (%s:%s): %s\n"</span>, hostname, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Walk the list for one that we can successfully connect to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Connect to the server */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">connect</span>(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">close</span>(clientfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Connect failed, try another */</span>  <span class="comment">//line:netp:openclientfd:closefd</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"open_clientfd: close failed: %s\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* All connects failed */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">/* The last connect succeeded */</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end open_clientfd */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * open_listenfd - Open and return a listening socket on port. This</span></span><br><span class="line"><span class="comment"> *     function is reentrant and protocol-independent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     On error, returns: </span></span><br><span class="line"><span class="comment"> *       -2 for getaddrinfo error</span></span><br><span class="line"><span class="comment"> *       -1 with errno set for other errors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin open_listenfd */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> listenfd, rc, optval=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* Accept connections */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* ... on any IP address */</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* ... using port number */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"getaddrinfo failed (port %s): %s\n"</span>, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Walk the list for one that we can bind to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Eliminates "Address already in use" error from bind */</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    <span class="comment">//line:netp:csapp:setsockopt</span></span><br><span class="line">                   (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;optval , <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bind the descriptor to the address */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">close</span>(listenfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Bind failed, try the next */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"open_listenfd close failed: %s\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* No address worked */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make it a listening socket ready to accept connection requests */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end open_listenfd */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[CSAPP] 机器表示</title>
      <link href="/2020/10/06/csapp-labs/csapp-pre-bomblab/"/>
      <url>/2020/10/06/csapp-labs/csapp-pre-bomblab/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一些容易忘的…x86-64下…</p></blockquote><ul><li>寄存器：程序计数器PC(%rsp) + 整数寄存器(16*64bit) + 条件码寄存器 + 一组向量寄存器</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006162747.png" width="500px"> </div><p>生成1字节和2字节的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0</p><ul><li>寻址方式</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006164718.png" width="500px"> </div><ul><li>压栈和出栈指令</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006164337.png" width="500px"> </div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushq %rbp</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subq $8,%rsp;栈指针减</span><br><span class="line">movq %rbp,(%rsp);store</span><br></pre></td></tr></table></figure><ul><li><p>lea 加载有效地址</p><p>目的：将有效地址写入到目的操作数，<strong>根本就没有引用内存</strong></p><p>leaq 7(%rdx,%rdx,4),%rax  如%rdx为x，则将%rax设置为5x+7</p></li><li><p>过程</p><ul><li>传递控制：进入Q时，PC被设置为Q代码的起始地址，返回时，PC设置为P中调用Q后的指令</li><li>传递数据：P必须向Q提供一个或多个参数，Q必须能够向P返回一个值</li><li>分配和释放内存：开始时Q会分配局部空间，返回前必须释放这些空间</li></ul></li><li><p>运行时栈</p><ul><li>通过寄存器传参最多只能6个，超过6个需要P在自己的栈帧里存储好这些参数</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006170142.png" width="500px"> </div><ul><li><p>转移控制</p><ul><li><p>call Q</p><p>把返回地址压入栈，并把PC设为Q的起始地址</p></li><li><p>ret</p><p>会从栈中弹出地址A，并把PC设置为返回地址（call指令的下一条）</p></li></ul></li><li><p>数据传送</p></li></ul><p>x86-64中，可以通过寄存器最多传递6个整型参（例如整数和指针）参数。寄存器的使用是有特殊顺序的，名字取决于数据类型大小</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006171042.png" width="500px"> </div><p>如果参数大于6，则把参数7~n放到栈上，<strong>参数7位于栈顶</strong>。通过栈传递参数时，所有的数据大小都向8对齐</p><ul><li><p>栈上的局部存储</p><p>有时候，局部数据必须存放在内存里：</p><ul><li>寄存器不足够存放所有的本地数据</li><li>对一个局部变量使用地址运算符’&amp;’，因此必须能够为它产生一个地址</li><li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到</li></ul></li><li><p>寄存器中的局部存储空间</p><ul><li>被调用者保存寄存器：%rbx,%rbp和%r12~%r15 过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改了值，然后在返回之前从栈中弹出旧值</li><li>调用者保存寄存器：其他除了%rsp 过程Q可以随意修改这个寄存器，因为在调用之前保存是P的责任</li></ul></li><li><p>数据对齐</p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201006214508.png" width="500px"> </div>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB commands Summary</title>
      <link href="/2020/10/06/tools/GDB-summary/"/>
      <url>/2020/10/06/tools/GDB-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="summary-of-gdb-commands-for-x86-64-systems"><a class="markdownIt-Anchor" href="#summary-of-gdb-commands-for-x86-64-systems"></a> Summary of GDB commands for x86-64 Systems</h2><p>做csapp的lab时偶然发现了这个，存一下…</p><p><a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.txt" target="_blank" rel="noopener">原文地址</a></p><h3 id="starting"><a class="markdownIt-Anchor" href="#starting"></a> Starting:</h3><table><thead><tr><th>Command</th></tr></thead><tbody><tr><td>gdb</td></tr><tr><td>gdb &lt;file&gt;</td></tr></tbody></table><h3 id="running-and-stopping"><a class="markdownIt-Anchor" href="#running-and-stopping"></a> Running and stopping</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>quit</td><td>Exit gdb</td></tr><tr><td>run</td><td>Run program</td></tr><tr><td>run 1 2 3</td><td>Run program with command-line arguments 1 2 3</td></tr><tr><td>kill</td><td>Stop the program</td></tr><tr><td>quit</td><td>Exit gdb</td></tr><tr><td>Ctrl-d</td><td>Exit gdb</td></tr></tbody></table><p>Note: Ctrl-C does not exit from gdb, but halts the current gdb command</p><h3 id="breakpoints"><a class="markdownIt-Anchor" href="#breakpoints"></a> Breakpoints</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>break sum</td><td>Set breakpoint at the entry to function sum</td></tr><tr><td>break *0x80483c3</td><td>Set breakpoint at address 0x80483c3</td></tr><tr><td>delete 1</td><td>Delete breakpoint 1</td></tr><tr><td>disable 1</td><td>Disable the breakpoint 1 (gdb numbers each breakpoint you create)</td></tr><tr><td>enable 1</td><td>Enable breakpoint 1</td></tr><tr><td>delete</td><td>Delete all breakpoints</td></tr><tr><td>clear sum</td><td>Clear any breakpoints at the entry to function sum</td></tr></tbody></table><h3 id="execution"><a class="markdownIt-Anchor" href="#execution"></a> Execution</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>stepi</td><td>Execute one instruction</td></tr><tr><td>stepi 4</td><td>Execute four instructions</td></tr><tr><td>nexti</td><td>Like stepi, but proceed through function calls without stopping</td></tr><tr><td>step</td><td>Execute one C statement</td></tr><tr><td>continue</td><td>Resume execution until the next breakpoint</td></tr><tr><td>until 3</td><td>Continue executing until program hits breakpoint 3</td></tr><tr><td>finish</td><td>Resume execution until current function returns</td></tr><tr><td>call sum(1, 2)</td><td>Call sum(1,2) and print return value</td></tr></tbody></table><h3 id="examining-code"><a class="markdownIt-Anchor" href="#examining-code"></a> Examining code</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>disas</td><td>Disassemble current function</td></tr><tr><td>disas sum</td><td>Disassemble function sum</td></tr><tr><td>disas 0x80483b7</td><td>Disassemble function around 0x80483b7</td></tr><tr><td>disas 0x80483b7 0x80483c7</td><td>Disassemble code within specified address range</td></tr><tr><td></td><td></td></tr><tr><td>print /x $rip</td><td>Print program counter in hex</td></tr><tr><td>print /d $rip</td><td>Print program counter in decimal</td></tr><tr><td>print /t $rip</td><td>Print program counter in binary</td></tr></tbody></table><h2 id="examining-data"><a class="markdownIt-Anchor" href="#examining-data"></a> Examining data</h2><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>print /d $rax</td><td>Print contents of %rax in decimal</td></tr><tr><td>print /x $rax</td><td>Print contents of %rax in hex</td></tr><tr><td>print /t $rax</td><td>Print contents of %rax in binary</td></tr><tr><td>print /d (int)$rax</td><td>Print contents of %rax in decimal after sign-extending lower 32-bits.</td></tr></tbody></table><p>You need this to print 32-bit, negative numbers stored in the lower 32 bits of %rax. For example, if the lower 32-bits of %rax store 0xffffffff, you will see</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span> <span class="variable">$rax</span></span><br><span class="line"><span class="variable">$1</span> = 4294967295</span><br><span class="line">(gdb) <span class="built_in">print</span> (int)<span class="variable">$rax</span></span><br><span class="line"><span class="variable">$2</span> = -1</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>print 0x100</td><td>Print decimal representation of 0x100</td></tr><tr><td>print /x 555</td><td>Print hex representation of 555</td></tr><tr><td>print /x ($rsp+8)</td><td>Print (contents of %rsp) + 8 in hex</td></tr><tr><td>print *(int *) 0xbffff890</td><td>Print integer at address 0xbffff890</td></tr><tr><td>print *(int *) ($rsp+8)</td><td>Print integer at address %rsp + 8</td></tr><tr><td>print (char *) 0xbfff890</td><td>Examine a string stored at 0xbffff890</td></tr><tr><td></td><td></td></tr><tr><td>x/w   0xbffff890</td><td>Examine (4-byte) word starting at address 0xbffff890</td></tr><tr><td>x/w   $rsp</td><td>Examine (4-byte) word starting at address in $rsp</td></tr><tr><td>x/wd  $rsp</td><td>Examine (4-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td>x/2w  $rsp</td><td>Examine two (4-byte) words starting at address in $rsp</td></tr><tr><td>x/2wd $rsp</td><td>Examine two (4-byte) words starting at address in $rsp. Print in decimal</td></tr><tr><td>x/g   $rsp</td><td>Examine (8-byte) word starting at address in $rsp.</td></tr><tr><td>x/gd  $rsp</td><td>Examine (8-byte) word starting at address in $rsp. Print in decimal</td></tr><tr><td>x/a   $rsp</td><td>Examine address in $rsp. Print as offset from previous global symbol.</td></tr><tr><td>x/s   0xbffff890</td><td>Examine a string stored at 0xbffff890</td></tr><tr><td>x/20b sum</td><td>Examine first 20 opcode bytes of function sum</td></tr><tr><td>x/10i sum</td><td>Examine first 10 instructions of function sum</td></tr></tbody></table><p>Note: the format string for the ‘x’ command has the general form x/[NUM][SIZE][FORMAT] where</p><blockquote><p>NUM  = number of objects to display<br />SIZE = size of each object (b=byte, h=half-word, w=word, g=giant (quad-word))<br />FORMAT = how to display each object (d=decimal, x=hex, o=octal, etc.)</p></blockquote><p>If you don’t specify SIZE or FORMAT, either a default value, or the last value you specified in a previous ‘print’ or ‘x’ command is used.</p><h3 id="useful-information"><a class="markdownIt-Anchor" href="#useful-information"></a> Useful information</h3><table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody><tr><td>backtrace</td><td>Print the current address and stack backtrace</td></tr><tr><td>where</td><td>Print the current address and stack backtrace</td></tr><tr><td></td><td></td></tr><tr><td>info program</td><td>Print current status of the program)</td></tr><tr><td>info functions</td><td>Print functions in program</td></tr><tr><td>info stack</td><td>Print backtrace of the stack)</td></tr><tr><td>info frame</td><td>Print information about the current stack frame</td></tr><tr><td>info registers</td><td>Print registers and their contents</td></tr><tr><td>info breakpoints</td><td>Print status of user-settable breakpoints</td></tr><tr><td></td><td></td></tr><tr><td>display /FMT EXPR</td><td>Print expression EXPR using format FMT every time GDB stops</td></tr><tr><td>undisplay</td><td>Turn off display mode</td></tr><tr><td>help</td><td>Get information about gdb</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Labs </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS143 编译原理-3</title>
      <link href="/2020/10/06/cs143/cs143-3/"/>
      <url>/2020/10/06/cs143/cs143-3/</url>
      
        <content type="html"><![CDATA[<h2 id="语法分析2"><a class="markdownIt-Anchor" href="#语法分析2"></a> 语法分析2</h2><h3 id="first集"><a class="markdownIt-Anchor" href="#first集"></a> First集</h3><h4 id="如何构建parsing-table-构建ll1parsing-table需要哪些条件"><a class="markdownIt-Anchor" href="#如何构建parsing-table-构建ll1parsing-table需要哪些条件"></a> 如何构建parsing table 构建LL(1)parsing table需要哪些条件</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003132022.png" width="600px"> </div><p>[上图解释]</p><p>给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>α</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">A, \alpha, t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span></span></span></span> 在什么情况下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">T[A, t]=\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>能成立？</p><p>第一种情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>通过一步或多步推导能推出t，且t处在第一个位置，这时候说t属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的First集；</p><p>第二种情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>不能直接推出t（t不属于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的First集），但A能推出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>能推出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>，且在某个产生式中t位置在A后，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">T[A, t]=\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>也能成立，且称t属于A的Follow集</p><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003135005.png" width="300px"> </div><p>一些可推规则：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003135447.png" width="500px"> </div><p>求First集的一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003140150.png" width="500px"> </div><h3 id="follow集"><a class="markdownIt-Anchor" href="#follow集"></a> Follow集</h3><h4 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003162550.png" width="300px"> </div><p>一些可推规则：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003163011.png" width="400px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003163151.png" width="400px"> </div><p>求First集的一个例子，需要用到First集：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003164657.png" width="600px"> </div><h3 id="ll1-pasring-tables"><a class="markdownIt-Anchor" href="#ll1-pasring-tables"></a> LL(1) Pasring Tables</h3><p>使用First集和Follow集来构建LL(1) parsing table</p><p>目的：对于CFG G，构建一个parsing table T</p><p>对每一个在G中的产生式进行以下算法：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003170101.png" width="400px"> </div><p>考虑每个生成式在右侧第一个位置能生成什么</p><p>一个生成LL(1) parsing table 的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003170958.png" width="550px"> </div><p>如果走到了表格中的空白区域则说明解析错误</p><p>如果对一个左递归的grammar构建parsing table：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">S\rightarrow Sa|b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord mathdefault">b</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201003171506.png" width="400px"> </div><p>构建出来的parsing table中的某些单元格中可能存在多种选择，则这个语法不是LL(1)的</p><p>[not left factored] [left recursive] [ambiguous] [other] 都不是LL(1)的，实际上大多数编程语言的CFG都不是LL(1)的，LL(1)语法太弱</p><h3 id="自下而上的解析-bottom-up-parsing"><a class="markdownIt-Anchor" href="#自下而上的解析-bottom-up-parsing"></a> 自下而上的解析 Bottom-Up Parsing</h3><p>自下而上解析比自上而下解析更加通用，且也高效，用到了自上而下的思想，是大多数编译器首选的方法</p><ul><li>自下而上解析不需要left-factored语法</li></ul><p>一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/3/20201004104247.png" width="500px"> </div><p><strong>reduce 规约</strong></p><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimage%5C20201007153346.png" alt="20201007153346" /></p><p>关于bottom-up parsing的重要<strong>Fact #1</strong>：</p><p>bottom-up parsing是最右推导的反向实现</p><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimage%5C20201007154748.png" alt="20201007154748" /></p><h3 id="移位规约解析-shift-reduce-parsing"><a class="markdownIt-Anchor" href="#移位规约解析-shift-reduce-parsing"></a> 移位规约解析 Shift Reduce Parsing</h3><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimage%5C20201007155055.png" alt="20201007155055" /></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span>一定是终结符，才能使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">X\rightarrow \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span></p><p><img src="C:%5CUsers%5Cjxhnw%5CDesktop%5Cimage%5C20201007163859.png" alt="20201007163859" /></p><p>右边的substring是还未parse的，左边的substring包含终结符和非终结符</p>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CSAPP] Bomb Lab</title>
      <link href="/2020/10/06/csapp-labs/csapp-bomblab/"/>
      <url>/2020/10/06/csapp-labs/csapp-bomblab/</url>
      
        <content type="html"><![CDATA[<h2 id="bomb-lab"><a class="markdownIt-Anchor" href="#bomb-lab"></a> Bomb Lab</h2><p>传说中的bomb lab，我开始以为这名字意思是更改了程序汇编代码，让你修复…直到看了writeup…</p><p>一些预备知识，主要为<a href="https://wfc.ink/2020/10/06/csapp-pre-bomblab/">CSAPP第三章</a></p><blockquote><p>题目大致意思就是不给源码（但给了源码框架），然你通过各种工具（gdb，objdump）调试，获取6次正确的输入。输入错误字符串会BOOMMMM !</p></blockquote><p>部分源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">initialize_bomb();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"which to blow yourself up. Have a nice day!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">                                  * Let me know how they did it. */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Phase 1 defused. How about the next one?\n"</span>);</span><br></pre></td></tr></table></figure><h3 id="phase_1"><a class="markdownIt-Anchor" href="#phase_1"></a> phase_1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$objdump</span> -d bomb &gt; log.txt</span><br></pre></td></tr></table></figure><p>main函数中调用phase_1的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400e32:       e8 67 06 00 00          callq  40149e &lt;read_line&gt;;读入一串字符，地址存在%rax</span><br><span class="line">400e37:       48 89 c7                mov    %rax,%rdi;%mov到%rdi</span><br><span class="line">400e3a:       e8 a1 00 00 00          callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:       e8 80 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure><p>phase_1的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400ee4:       be 00 24 40 00          mov    $0x402400,%esi;字符常量地址存入%esi</span><br><span class="line">  400ee9:       e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:       85 c0                   test   %eax,%eax;判断返回值是否为0</span><br><span class="line">  400ef0:       74 05                   je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:       e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400efb:       c3                      retq</span><br></pre></td></tr></table></figure><p>strings_not_equal的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;:</span><br><span class="line">  401338:       41 54                   push   %r12</span><br><span class="line">  40133a:       55                      push   %rbp</span><br><span class="line">  40133b:       53                      push   %rbx</span><br><span class="line">  40133c:       48 89 fb                mov    %rdi,%rbx;读入字符串地址</span><br><span class="line">  40133f:       48 89 f5                mov    %rsi,%rbp;字符常量地址</span><br><span class="line">  401342:       e8 d4 ff ff ff          callq  40131b &lt;string_length&gt;</span><br><span class="line">  401347:       41 89 c4                mov    %eax,%r12d;求长度结果</span><br><span class="line">  40134a:       48 89 ef                mov    %rbp,%rdi</span><br><span class="line">  40134d:       e8 c9 ff ff ff          callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:       ba 01 00 00 00          mov    $0x1,%edx;求长度结果</span><br><span class="line">  401357:       41 39 c4                cmp    %eax,%r12d;比较长度，如不等长直接返回</span><br><span class="line">  40135a:       75 3f                   jne    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40135c:       0f b6 03                movzbl (%rbx),%eax</span><br><span class="line">  40135f:       84 c0                   test   %al,%al</span><br><span class="line">  401361:       74 25                   je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:       3a 45 00                cmp    0x0(%rbp),%al</span><br><span class="line">  401366:       74 0a                   je     401372 &lt;strings_not_equal+0x3a&gt;</span><br><span class="line">  401368:       eb 25                   jmp    40138f &lt;strings_not_equal+0x57&gt;</span><br><span class="line">  40136a:       3a 45 00                cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:       0f 1f 00                nopl   (%rax)</span><br><span class="line">  401370:       75 24                   jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:       48 83 c3 01             add    $0x1,%rbx;双字符串指针都+1判断是否相等</span><br><span class="line">  401376:       48 83 c5 01             add    $0x1,%rbp</span><br><span class="line">  40137a:       0f b6 03                movzbl (%rbx),%eax</span><br><span class="line">  40137d:       84 c0                   test   %al,%al</span><br><span class="line">  40137f:       75 e9                   jne    40136a &lt;strings_not_equal+0x32&gt;</span><br><span class="line">  401381:       ba 00 00 00 00          mov    $0x0,%edx</span><br><span class="line">  401386:       eb 13                   jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:       ba 00 00 00 00          mov    $0x0,%edx</span><br><span class="line">  40138d:       eb 0c                   jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:       ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">  401394:       eb 05                   jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:       ba 01 00 00 00          mov    $0x1,%edx</span><br><span class="line">  40139b:       89 d0                   mov    %edx,%eax</span><br><span class="line">  40139d:       5b                      pop    %rbx</span><br><span class="line">  40139e:       5d                      pop    %rbp</span><br><span class="line">  40139f:       41 5c                   pop    %r12</span><br><span class="line">  4013a1:       c3                      retq</span><br></pre></td></tr></table></figure><p>string_length的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040131b &lt;string_length&gt;:</span><br><span class="line">  40131b:       80 3f 00                cmpb   $0x0,(%rdi);指针判空，空指针直接返回0</span><br><span class="line">  40131e:       74 12                   je     401332 &lt;string_length+0x17&gt;</span><br><span class="line">  401320:       48 89 fa                mov    %rdi,%rdx</span><br><span class="line">  401323:       48 83 c2 01             add    $0x1,%rdx;每次地址+1，循环检测&#39;\0&#39;</span><br><span class="line">  401327:       89 d0                   mov    %edx,%eax</span><br><span class="line">  401329:       29 f8                   sub    %edi,%eax;返回的长度</span><br><span class="line">  40132b:       80 3a 00                cmpb   $0x0,(%rdx)</span><br><span class="line">  40132e:       75 f3                   jne    401323 &lt;string_length+0x8&gt;</span><br><span class="line">  401330:       f3 c3                   repz retq</span><br><span class="line">  401332:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401337:       c3                      retq</span><br></pre></td></tr></table></figure><p>phase_1挺简单，就判断输入的字符串和给定的字符串常量是否相等，不相同则boom。输入的字符串起始地址为%rdi，给定的字符串起始地址为%esi，调用strings_not_equal判断是否相同。strings_not_equal首先调用string_length求字符串长度，不相同则直接返回，string_length就使用每次指针+1，检测所指内存区域是否为’\0’的方式求长度。如长度相等则再依次对比每个字符，不相等则直接返回。</p><p>所以，需要输入的字符串就是给定的字符串常量，位于内存0x402400，使用gdb打印出内存信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gdb ./bomb</span><br><span class="line">(gdb) b phase_1</span><br><span class="line">Breakpoint 1 at 0x400ee0</span><br><span class="line">(gdb) r</span><br><span class="line">[随意的错误输入]</span><br><span class="line">Breakpoint 1, 0x0000000000400ee0 <span class="keyword">in</span> phase_1 ()</span><br><span class="line">(gdb) <span class="built_in">print</span> (char*) 0x402400</span><br><span class="line"><span class="variable">$1</span> = 0x402400 <span class="string">"Border relations with Canada have never been better."</span></span><br></pre></td></tr></table></figure><p><strong>答案</strong>是 Border relations with Canada have never been better.</p><h3 id="phase_2"><a class="markdownIt-Anchor" href="#phase_2"></a> phase_2</h3><p>phase_2的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:       55                      push   %rbp</span><br><span class="line">  400efd:       53                      push   %rbx</span><br><span class="line">  400efe:       48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:       48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  400f05:       e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:       83 3c 24 01             cmpl   $0x1,(%rsp);和1比较</span><br><span class="line">  400f0e:       74 20                   je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:       e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:       eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:       8b 43 fc                mov    -0x4(%rbx),%eax;前一个单元的值</span><br><span class="line">  400f1a:       01 c0                   add    %eax,%eax;前一个单元的值*2</span><br><span class="line">  400f1c:       39 03                   cmp    %eax,(%rbx);前一个单元的值*2和当前单元比较</span><br><span class="line">  400f1e:       74 05                   je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:       e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:       48 83 c3 04             add    $0x4,%rbx</span><br><span class="line">  400f29:       48 39 eb                cmp    %rbp,%rbx</span><br><span class="line">  400f2c:       75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:       eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:       48 8d 5c 24 04          lea    0x4(%rsp),%rbx;将%rsp所指单元的上一个单元地址传%rbx</span><br><span class="line">  400f35:       48 8d 6c 24 18          lea    0x18(%rsp),%rbp;将%rsp+24所指单元的地址传%rbx，作为循环结束条件</span><br><span class="line">  400f3a:       eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:       48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:       5b                      pop    %rbx</span><br><span class="line">  400f41:       5d                      pop    %rbp</span><br><span class="line">  400f42:       c3                      retq</span><br></pre></td></tr></table></figure><p>read_six_numbers的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:       48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  401460:       48 89 f2                mov    %rsi,%rdx;存的就是phase_2栈帧底部的地址</span><br><span class="line">  401463:       48 8d 4e 04             lea    0x4(%rsi),%rcx;传地址参数到寄存器</span><br><span class="line">  401467:       48 8d 46 14             lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:       48 89 44 24 08          mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:       48 8d 46 10             lea    0x10(%rsi),%rax</span><br><span class="line">  401474:       48 89 04 24             mov    %rax,(%rsp)</span><br><span class="line">  401478:       4c 8d 4e 0c             lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:       4c 8d 46 08             lea    0x8(%rsi),%r8</span><br><span class="line">  401480:       be c3 25 40 00          mov    $0x4025c3,%esi</span><br><span class="line">  401485:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  40148a:       e8 61 f7 ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:       83 f8 05                cmp    $0x5,%eax;返回值：读取到的数量</span><br><span class="line">  401492:       7f 05                   jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:       e8 a1 ff ff ff          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:       48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  40149d:       c3                      retq</span><br></pre></td></tr></table></figure><p>phase_2主要是个循环，read_six_number将phase_2栈帧地址较低处6个int型内存单元的地址传给__isoc99_sscanf@plt，sscanff读取6个数到phase_2栈帧底部的6个单元，并返回读取到的int数量，存到%eax，如果数量小于6，则boom。</p><p>在phase_2的汇编代码中，首先将phase_2栈帧的最低地址单元与常数1相比，如果不等则boom，如果相等，则进行循环：用%rbx记录当前所指单元，将前一个单元的值的两倍和当前单元比较（第一个单元值为1），不相等则boom。当%rbx和%rbp相等时，循环结束。</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/csapp/20201007112329.png" width="250px"> </div><p><strong>答案</strong>是 1 2 4 8 16 32</p><h3 id="phase_3"><a class="markdownIt-Anchor" href="#phase_3"></a> phase_3</h3><p>phase_3的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:       48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  400f47:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:       48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:       be cf 25 40 00          mov    $0x4025cf,%esi;&quot;%d %d&quot;</span><br><span class="line">  400f56:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400f5b:       e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:       83 f8 01                cmp    $0x1,%eax</span><br><span class="line">  400f63:       7f 05                   jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:       e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:       83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:       77 3c                   ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:       8b 44 24 08             mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:       ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8);跳转表</span><br><span class="line">  400f7c:       b8 cf 00 00 00          mov    $0xcf,%eax</span><br><span class="line">  400f81:       eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:       b8 c3 02 00 00          mov    $0x2c3,%eax</span><br><span class="line">  400f88:       eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:       b8 00 01 00 00          mov    $0x100,%eax</span><br><span class="line">  400f8f:       eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:       b8 85 01 00 00          mov    $0x185,%eax</span><br><span class="line">  400f96:       eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:       b8 ce 00 00 00          mov    $0xce,%eax</span><br><span class="line">  400f9d:       eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:       b8 aa 02 00 00          mov    $0x2aa,%eax</span><br><span class="line">  400fa4:       eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:       b8 47 01 00 00          mov    $0x147,%eax</span><br><span class="line">  400fab:       eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:       e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400fb7:       eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:       b8 37 01 00 00          mov    $0x137,%eax</span><br><span class="line">  400fbe:       3b 44 24 0c             cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:       74 05                   je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:       e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:       48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  400fcd:       c3                      retq</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print (char*) 0x4025cf</span><br><span class="line">$2 &#x3D; 0x4025cf &quot;%d %d&quot;</span><br></pre></td></tr></table></figure><p>phase_3主要内容为switch和跳转表，sscanf读取至少两个数，否则就boom。第一个参数在%rsp+8处，第二个参数在%rsp+12处。第一个参数不能大于7，否则就boom</p><p>0x402470处是跳转表的首地址，可以用gdb打印出跳转表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print &#x2F;x *0x402470 @16</span><br><span class="line">$1 &#x3D; &#123;0x400f7c, 0x0, 0x400fb9, 0x0, 0x400f83, 0x0, 0x400f8a, 0x0, 0x400f91, 0x0,</span><br><span class="line">  0x400f98, 0x0, 0x400f9f, 0x0, 0x400fa6, 0x0&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，%rsp+8中不同的值，也就是%rax中不同的值对应着跳转表中不同的跳转地址，尝试使%rax等于1，则跳转到0x400fb9处指令，则第二个参数%rsp+12需要等于0x137才能使下一条cmp指令相等。</p><p>其中一个<strong>答案</strong>为1 311</p><h3 id="phase_4"><a class="markdownIt-Anchor" href="#phase_4"></a> phase_4</h3><p>phase_4的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:       48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  401010:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  401015:       48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  40101a:       be cf 25 40 00          mov    $0x4025cf,%esi</span><br><span class="line">  40101f:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401024:       e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:       83 f8 02                cmp    $0x2,%eax</span><br><span class="line">  40102c:       75 07                   jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:       83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  401033:       76 05                   jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">  401035:       e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:       ba 0e 00 00 00          mov    $0xe,%edx</span><br><span class="line">  40103f:       be 00 00 00 00          mov    $0x0,%esi</span><br><span class="line">  401044:       8b 7c 24 08             mov    0x8(%rsp),%edi</span><br><span class="line">  401048:       e8 81 ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">  40104d:       85 c0                   test   %eax,%eax</span><br><span class="line">  40104f:       75 07                   jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:       83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)</span><br><span class="line">  401056:       74 05                   je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:       e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:       48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  401061:       c3                      retq</span><br></pre></td></tr></table></figure><p>func4的汇编代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400fd2:       89 d0                   mov    %edx,%eax</span><br><span class="line">  400fd4:       29 f0                   sub    %esi,%eax</span><br><span class="line">  400fd6:       89 c1                   mov    %eax,%ecx</span><br><span class="line">  400fd8:       c1 e9 1f                shr    $0x1f,%ecx</span><br><span class="line">  400fdb:       01 c8                   add    %ecx,%eax</span><br><span class="line">  400fdd:       d1 f8                   sar    %eax</span><br><span class="line">  400fdf:       8d 0c 30                lea    (%rax,%rsi,1),%ecx</span><br><span class="line">  400fe2:       39 f9                   cmp    %edi,%ecx</span><br><span class="line">  400fe4:       7e 0c                   jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">  400fe6:       8d 51 ff                lea    -0x1(%rcx),%edx</span><br><span class="line">  i00fe9:       e8 e0 ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:       01 c0                   add    %eax,%eax</span><br><span class="line">  400ff0:       eb 15                   jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400ff7:       39 f9                   cmp    %edi,%ecx</span><br><span class="line">  400ff9:       7d 0c                   jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ffb:       8d 71 01                lea    0x1(%rcx),%esi</span><br><span class="line">  400ffe:       e8 cb ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">  401003:       8d 44 00 01             lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  40100b:       c3                      retq</span><br></pre></td></tr></table></figure><p>直接尝试写出c源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> <span class="built_in">step</span>, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* edi = target; esi = step; edx = limit */</span></span><br><span class="line">  <span class="keyword">int</span> temp = (limit - <span class="built_in">step</span>) * <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = temp + <span class="built_in">step</span>;</span><br><span class="line">  <span class="keyword">if</span> (mid &gt; target) &#123;</span><br><span class="line">    limit = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret1 = func4(target, <span class="built_in">step</span>, limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * ret1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= target) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">step</span> = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> ret2 = func4(target, <span class="built_in">step</span>, limit);</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">2</span> * ret2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong> 7 0</p><h3 id="phase_5"><a class="markdownIt-Anchor" href="#phase_5"></a> Phase_5</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:       53                      push   %rbx</span><br><span class="line">  401063:       48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  401067:       48 89 fb                mov    %rdi,%rbx</span><br><span class="line">  40106a:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:       00 00</span><br><span class="line">  401073:       48 89 44 24 18          mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:       31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:       e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:       83 f8 06                cmp    $0x6,%eax</span><br><span class="line">  401082:       74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:       e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:       eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:       0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  40108f:       88 0c 24                mov    %cl,(%rsp)</span><br><span class="line">  401092:       48 8b 14 24             mov    (%rsp),%rdx</span><br><span class="line">  401096:       83 e2 0f                and    $0xf,%edx</span><br><span class="line">  401099:       0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">  4010a0:       88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:       48 83 c0 01             add    $0x1,%rax</span><br><span class="line">  4010a8:       48 83 f8 06             cmp    $0x6,%rax</span><br><span class="line">  4010ac:       75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:       c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:       be 5e 24 40 00          mov    $0x40245e,%esi</span><br><span class="line">  4010b8:       48 8d 7c 24 10          lea    0x10(%rsp),%rdi</span><br><span class="line">  4010bd:       e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:       85 c0                   test   %eax,%eax</span><br><span class="line">  4010c4:       74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:       e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:       eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  4010d7:       eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:       48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:       64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:       00 00</span><br><span class="line">  4010e7:       74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:       e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:       48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:       5b                      pop    %rbx</span><br><span class="line">  4010f3:       c3                      retq</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Labs </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CSAPP] Data Lab</title>
      <link href="/2020/10/05/csapp-labs/csapp-datalab/"/>
      <url>/2020/10/05/csapp-labs/csapp-datalab/</url>
      
        <content type="html"><![CDATA[<h2 id="data-lab"><a class="markdownIt-Anchor" href="#data-lab"></a> Data Lab</h2><p>【踩的坑】在centos7下进行的实验，缺32位glibc, gcc库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[wangfangcao@wfcserver datalab-handout]$ make</span><br><span class="line">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c</span><br><span class="line">In file included from /usr/include/features.h:399:0,</span><br><span class="line">                 from /usr/include/stdio.h:27,</span><br><span class="line">                 from btest.c:16:</span><br><span class="line">/usr/include/gnu/stubs.h:7:27: fatal error: gnu/stubs-32.h: No such file or directory</span><br><span class="line"> <span class="comment"># include &lt;gnu/stubs-32.h&gt;</span></span><br><span class="line">                           ^</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>解决办法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install glibc-devel.i686</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[wangfangcao@wfcserver datalab-handout]$ make</span><br><span class="line">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-redhat-linux/4.8.5/libgcc_s.so when searching <span class="keyword">for</span> -lgcc_s</span><br><span class="line">/usr/bin/ld: cannot find -lgcc_s</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make: *** [btest] Error 1</span><br></pre></td></tr></table></figure><p>解决办法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y libgcc.i686</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Labs </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS143 编译原理-2</title>
      <link href="/2020/10/03/cs143/cs143-2/"/>
      <url>/2020/10/03/cs143/cs143-2/</url>
      
        <content type="html"><![CDATA[<h2 id="语法分析1"><a class="markdownIt-Anchor" href="#语法分析1"></a> 语法分析1</h2><p>有些语法（比如<strong>括号嵌套匹配</strong>无法使用正则表达式来表示）</p><p><strong>Paring</strong>:</p><ul><li><strong>Input</strong>: sequence of tokens from lexer （token序列）</li><li><strong>Output</strong>: parse tree of the program （语法树）</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928225221.png" width="500px"> </div> <h3 id="上下文无关文法-context-free-grammers-cfgs"><a class="markdownIt-Anchor" href="#上下文无关文法-context-free-grammers-cfgs"></a> 上下文无关文法 (Context-Free Grammers CFGs)</h3><ul><li><p>不是所有的strings都是合法的程序，所以需要Language来描述有效的strings，需要一个方法来区分有效和无效的strings</p></li><li><p>编程语言通常具有递归形式，CFGs可以是递归结构的一种自然标记</p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928225954.png" width="350px"> </div><p>终结符T 非终结符N 一个产生式集合</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200928235823.png" width="400px"> </div><p>从一个符号S开始，不断用产生式替换右边，直到右边没有非终结符为止</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929000352.png" width="400px"> </div><p>一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929000519.png" width="400px"> </div><p>CFG的目标：</p><ol><li>输出&quot;yes&quot; or “no”；并且输出语法树</li><li>处理error</li><li>CFG的实现（e.g., bison）</li></ol><h3 id="推导"><a class="markdownIt-Anchor" href="#推导"></a> 推导</h3><ul><li>Grammar <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>→</mo><mi>E</mi><mo>+</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mo>∗</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">E\rightarrow E+E|E*E|(E)|id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></li><li>String <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi><mo>∗</mo><mi>i</mi><mi>d</mi><mo>+</mo><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id*id+id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929203505.png" width="500px"> </div><p>这个例子的是left-most derivation，在每一步替换最左的non-terminal</p><p>right-most 和 left-most derivations 形成相同的parse tree</p><p><strong>A parse tree has</strong>:</p><ol><li>Terminals at the leaves</li><li>Non-terminals at the interior nodes</li></ol><p>一个derivation定义了一颗parse tree</p><h3 id="二义性-ambiguity"><a class="markdownIt-Anchor" href="#二义性-ambiguity"></a> 二义性 Ambiguity</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20200929205102.png" width="500px"> </div><p>一个grammer是ambiguity的如果有超过一颗parse tree</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201001113537.png" width="500px"> </div><p>解决ambiguity的方法是重写grammer，改变优先级；或者可以通过定义优先级</p><h3 id="error-handing"><a class="markdownIt-Anchor" href="#error-handing"></a> Error Handing</h3><ul><li>Panic mode</li><li>Error productions</li><li>Automatic local or global correction</li></ul><h3 id="ast-抽象语法树"><a class="markdownIt-Anchor" href="#ast-抽象语法树"></a> AST 抽象语法树</h3><p>像parse trees但是忽略了一些细节</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002144333.png" width="300px"> </div><ul><li><p>从具体的语义抽象 =&gt; 更加紧凑 &amp; 简单</p></li><li><p>编译器中重要的数据结构</p></li></ul><h3 id="递归下降解析-recursive-descent-parsing"><a class="markdownIt-Anchor" href="#递归下降解析-recursive-descent-parsing"></a> 递归下降解析 Recursive Descent Parsing</h3><p>(第一个parsing算法)</p><p>一个top-down parsing算法</p><ul><li>The parse tree is constructed<ul><li>From the top</li><li>From left to right</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002152907.png" width="500px"> </div><h4 id="递归下降算法的一般描述"><a class="markdownIt-Anchor" href="#递归下降算法的一般描述"></a> 递归下降算法的一般描述</h4><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002200003.png" width="400px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002200134.png" width="400px"> </div><ul><li><p>check TOKEN和当前输入流中所指的对象是否相等</p></li><li><p>检查和S的某一个产生式是否匹配</p></li><li><p>检查和S的任何产生式是否匹配</p></li></ul><p>一个编码的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002201258.png" width="400px"> </div><p>(PLUS: ’ + ')</p><ul><li>save保存初始指针</li><li>第一个产生式返回false则尝试第二个</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002201618.png" width="500px"> </div><h4 id="limitations-递归下降的局限性"><a class="markdownIt-Anchor" href="#limitations-递归下降的局限性"></a> Limitations 递归下降的局限性</h4><p>一旦找到一个能够用在非终结符元素的产生式的话，那么就没有回滚操作</p><ul><li>If a production for non-terminal X succeeds<ul><li>Cannot backtrack to try a different production for X later</li></ul></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002204605.png" width="800px"> </div><ul><li>这边所讲的递归下降并不通用，但是容易实现</li><li>通过提取左因子 left factoring，可以对这个算法进行rewrite</li></ul><h3 id="左递归-left-recursion"><a class="markdownIt-Anchor" href="#左递归-left-recursion"></a> 左递归 Left Recursion</h3><p>递归下降算法中的主要难点</p><p>左递归的例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002205539.png" width="300px"> </div><p><strong>Left Recursion 左递归</strong>:</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002205631.png" width="500px"> </div><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mi>a</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi>a</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi>a</mi><mi>a</mi><mo>…</mo></mrow><annotation encoding="application/x-tex">S\rightarrow Sa \rightarrow Saa \rightarrow Saaa \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span></p><p><strong>递归下降算法</strong>不适用于<strong>左递归</strong>情形</p><p>左递归语法的一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002210207.png" width="500px"> </div><p>主要原因是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>是最后的推导产生的，却在第一个位置，这不符合从左到右解析的原则</p><p><strong>可以使用右递归语法 right-recursion 进行重写</strong></p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002210454.png" width="500px"> </div><p><em>Dragon Book</em>中有消除左递归的具体算法</p><p>小结：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201002211241.png" width="350px"> </div><p>一般编译器中都会采取手写praser的做法，如gcc</p><h3 id="预测解析-predictive-parsing"><a class="markdownIt-Anchor" href="#预测解析-predictive-parsing"></a> 预测解析 Predictive Parsing</h3><ul><li><p>类似递归下降，但是praser能预测使用哪个产生式</p><ul><li>looking at the next few tokens</li><li>不回滚</li></ul></li><li><p>预测praser能接受LL(k)语法 (left-to-right, left-most derivation, look forward k tokens)</p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003003010.png" width="350px"> </div><p>在递归下降算法中，每一步都有许多产生式选择，如果选择错了就回滚</p><p>在LL(1)中，每一步都只有一种选择</p><h4 id="we-need-to-left-factor-the-grammar-提取左公因子"><a class="markdownIt-Anchor" href="#we-need-to-left-factor-the-grammar-提取左公因子"></a> We need to left-factor the grammar 提取左公因子</h4><p><strong>目的</strong>：消除一个非终结符的多个产生式的公共前缀</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003111250.png" width="250px"> </div><p>通过提取左公因式，可以将产生式的执行推迟进行，先prase公共的非终结符</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113332.png" width="500px"> </div><p>通过grammar生成parsing table</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113423.png" width="500px"> </div><ul><li><p>方法与递归下降类似，除了</p><ul><li>对于最左的非终结符S</li><li>look at下一个token</li><li>在表中找到对应的产生式</li></ul></li><li><p>用一个栈来存放之前的parse tree，栈顶是当前要parse的非终结符或者终结符</p></li></ul><p>算法：</p><p>($符号表示end of input)</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113459.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/2/20201003113532.png" width="500px"> </div>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS143 编译原理-1</title>
      <link href="/2020/09/28/cs143/cs143-1/"/>
      <url>/2020/09/28/cs143/cs143-1/</url>
      
        <content type="html"><![CDATA[<ul><li>编译器结构<ol><li>词法分析 (Lexical Analysis)</li><li>语法分析 (Parsing)</li><li>语义分析 (Semantic Analysis)</li><li>优化 (Optimization)</li><li>代码生成 (Code Generation)</li></ol></li></ul><p>早期的编译器和现在的编译器的对比：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927155639.png" width="500px"> </div><p>现在的编译器花了更多的时间在优化上面</p><h2 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h2><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927160531.png" width="500px"> </div><p>“Words” =&gt; “Tokens Class”: <strong>Identifier</strong>, <strong>keywords</strong>, ‘<strong>(</strong>’, ‘<strong>)</strong>’, <strong>numbers</strong>, …</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927160906.png" width="500px"> </div><p>词法分析器将字符子串分类成Tokens，传递给<strong>Parser</strong></p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927161438.png" width="500px"> </div><ul><li>Left-to-right scan =&gt; lookahead sometimes required 有时候需要向前几个字符参考，来确定当前的token</li></ul><h3 id="正则语言-regular-languages"><a class="markdownIt-Anchor" href="#正则语言-regular-languages"></a> 正则语言 Regular Languages</h3><ul><li>Regular expressions</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927164524.png" width="280px"> </div><p><strong>Epsilon</strong>不是空集，是一个只包含空字符的集合</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927164758.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927165627.png" width="500px"> </div><p>grammar: 文法</p><ul><li>Regular expressions (syntax) specify regular languages (set of strings)</li></ul><h3 id="形式化语言-formal-languages"><a class="markdownIt-Anchor" href="#形式化语言-formal-languages"></a> 形式化语言 Formal Languages</h3><ul><li><p><strong>Def.</strong> Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> be a set of characters (an alphabet).</p><p>A <strong>language</strong> over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> is a set of strings of characters drawn from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span></p></li><li><p>Meaning function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> maps <strong>syntax</strong> to <strong>semantics</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>:</mo><mi>E</mi><mi>x</mi><mi>p</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>s</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">L: Exp\rightarrow Sets\ of\ Strings</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">s</span></span></span></span></p></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927172527.png" width="500px"> </div><ul><li>Meaning is many to one<ul><li>Never one to many!</li></ul></li></ul><h3 id="lexical-specifications"><a class="markdownIt-Anchor" href="#lexical-specifications"></a> Lexical Specifications</h3><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msup><mi>A</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">AA^*=A^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232010.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232447.png" width="500px"> </div><p>最后一个表示补集</p><ul><li>如何预测一个s是不是属于L®</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232857.png" width="500px"> </div><p>写出所有类型token的正则表达式</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927232923.png" width="500px"> </div><p>构建R，R能匹配所有类型的token</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200927234514.png" width="500px"> </div><p>检查前缀是不是属于R，如果属于R，则一定属于R中的某个token类Rj，删除匹配完成的前缀接着进行第三步</p><p><strong>一些问题</strong>：</p><ol><li><p>当较短和较长的字符串都匹配时，选较长的  “Maximal Match”</p></li><li><p>当同一个字符串和多个正则表达式匹配时，根据优先级</p></li><li><p>What if no rule matches? 添加一个错误类，优先级设置成最低</p></li></ol><h3 id="有限自动机"><a class="markdownIt-Anchor" href="#有限自动机"></a> 有限自动机</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928001815.png" width="450px"> </div><p>有限自动机是一种算法的实现</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928002027.png" width="450px"> </div><ul><li>在一个状态，读取一些输入，变成另一个状态</li><li>如果读完输入，最后处于接受状态，则accept，否则就reject</li></ul><h4 id="dfa-deterministic-finite-automata-确定的有限状态自动机"><a class="markdownIt-Anchor" href="#dfa-deterministic-finite-automata-确定的有限状态自动机"></a> DFA (Deterministic Finite Automata) 确定的有限状态自动机</h4><ul><li>对于一个input，只能有一个转换</li><li>NO <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>-moves</li><li>执行更快，因为每一步都没有选择</li></ul><h4 id="nfa-nondeterministic-finite-automata-不确定的优先状态自动机"><a class="markdownIt-Anchor" href="#nfa-nondeterministic-finite-automata-不确定的优先状态自动机"></a> NFA (Nondeterministic Finite Automata) 不确定的优先状态自动机</h4><ul><li>对于一个input，可以有多个转换</li><li>have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>-moves</li><li>smaller</li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928153706.png" width="250px"> </div><h3 id="正则表达式-nfas"><a class="markdownIt-Anchor" href="#正则表达式-nfas"></a> 正则表达式 =&gt; NFAs</h3><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161156.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928154159.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928154222.png" width="500px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160059.png" width="500px"> </div><p>一个例子：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160203.png" width="500px"> </div><h3 id="nfa-to-dfa"><a class="markdownIt-Anchor" href="#nfa-to-dfa"></a> NFA to DFA</h3><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi><mo>−</mo><mi>c</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\epsilon -closure</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span></li></ul><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928160434.png" width="500px"> </div><p>相应的<strong>DFA</strong>：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161008.png" width="500px"> </div><h3 id="implementing-finite-automata"><a class="markdownIt-Anchor" href="#implementing-finite-automata"></a> Implementing Finite Automata</h3><p>DFA可以用一张二维的表来表示：</p><ol><li>一维是states</li><li>一维是输入符号</li><li>表中是转换的下一个states</li></ol><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161404.png" width="250px"> </div><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161500.png" width="500px"> </div><p>一种更加节省空间的做法：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161534.png" width="500px"> </div><p>NFA直接转换成table：</p><div align='center'> <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/cs143/1/20200928161835.png" width="500px"> </div><p>节省空间，但是这样比NFA=&gt;DFA=&gt;table慢</p>]]></content>
      
      
      <categories>
          
          <category> 编译 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS143 </tag>
            
            <tag> 词法分析 </tag>
            
            <tag> Lex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构-1</title>
      <link href="/2020/04/30/redis/redis-data-structure-1/"/>
      <url>/2020/04/30/redis/redis-data-structure-1/</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串sds"><a class="markdownIt-Anchor" href="#简单动态字符串sds"></a> 简单动态字符串sds</h2><p>sds 的源码主要在 sds.h 和 sds.c 中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 buf 数组是柔性数组，在分配的时候不占内存大小</p><p>sds.h 中还有两个 inline 的静态函数，用于返回实际保存的字符串长度和可用空间的字符串长度</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span> <span class="comment">//buf地址往回sizeof(struct sdshdr))</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 可用空间的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边用了一个骚操作，用 buf 的数组指针减去8字节，就得到了结构体的初始位置，也就是结构体的指针：</p><div align='center'>  <img src="https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/redis/20200502162607.png" height="180px"></div>这个技巧在 redis 中多处用到<p>sds 主要接口函数声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 sds T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定字符串 init ，创建一个包含同样字符串的 sds T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个只保存了空字符串 "" 的 sds T = O(1)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sds 实际保存的字符串的长度 T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制给定 sds 的副本 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放给定的 sds T = O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sds 可用空间的长度 T = O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 sds 扩充至指定长度，未使用的空间以 0 字节填充 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定字符串 t 追加到 sds 的末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将另一个 sds 追加到一个 sds 的末尾 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串 t 的前 len 个字符复制到 sds s 当中，并在字符串的最后添加终结符 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串复制到 sds 当中，覆盖原有的字符 T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;</span><br></pre></td></tr></table></figure><p>其中几个：</p><ul><li><strong>sdsnew</strong><br />根据给定字符串 init ，创建一个包含同样字符串的 sds</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用了：</p><ul><li><strong>sdsnewlen</strong><br />根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>); <span class="comment">// 结构体+buf数组+'\0'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 zmalloc 和 zcalloc 为 redis 使用的内存管理工具，在 zmalloc.c 和 zmalloc.h 中定义</p><h2 id="双端链表"><a class="markdownIt-Anchor" href="#双端链表"></a> 双端链表</h2><p>双端链表 的源码主要在 adlist.h 和 adlist.c 中</p><p>双端链表节点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>双端链表结构:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>为了规范化的宏定义函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回给定链表所包含的节点数量</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表头节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表尾节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="comment">// 返回给定节点的前置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="comment">// 返回给定节点的后置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="comment">// 返回给定节点的值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表 l 的值复制函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="comment">// 将链表 l 的值释放函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="comment">// 将链表的对比函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的值复制函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值释放函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值对比函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure><p>几个主要接口函数：</p><ul><li><strong>listCreate</strong><br />创建一个新的链表 T = O(1)</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listRelease</strong><br />释放整个链表，以及链表中所有节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向头指针</span></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// 遍历整个链表</span></span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放节点结构</span></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表结构</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listAddNodeHead</strong><br />将一个包含有给定值指针 value 的新节点添加到链表的表头</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值指针</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点到空链表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 添加节点到非空链表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 redis 双端队列中使用了迭代器这一技巧</p><p>双端链表迭代器：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前迭代到的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代的方向</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line"></span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure><ul><li><strong>listGetIterator</strong><br />为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为迭代器分配内存</span></span><br><span class="line">    listIter *iter;</span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录迭代方向</span></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listNext</strong><br />返回迭代器当前所指向的节点<br />这个函数其实有两个作用：返回当前迭代器指向的节点 + 使迭代器指向下一个节点（我刚开始还没明白只return了一个current，怎么把iter传出去，后来看了这个函数的使用才知道，因为函数传入的是指针，只要定义一个listIter类型的指针，一直使用该函数就能迭代了</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据方向选择下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>listDup</strong><br />复制整个链表<br />其中就使用了上述的listNext来进行迭代</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新链表</span></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置节点值处理函数</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代整个输入链表</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制节点值到新节点</span></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将节点添加到链表</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回副本</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
