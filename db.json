{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/melody/source/melody-favicon.ico","path":"melody-favicon.ico","modified":1,"renderable":1},{"_id":"themes/melody/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":1,"renderable":1},{"_id":"themes/melody/source/css/404.styl","path":"css/404.styl","modified":1,"renderable":1},{"_id":"themes/melody/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/melody/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/melody/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/melody/source/js/fireworks.js","path":"js/fireworks.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/copy.js","path":"js/copy.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/head.js","path":"js/head.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/katex.js","path":"js/katex.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/scroll.js","path":"js/scroll.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/sidebar.js","path":"js/sidebar.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/transition.js","path":"js/transition.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/melody/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","path":"js/third-party/reveal/markdown.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","path":"js/third-party/reveal/marked.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","path":"js/third-party/reveal/notes.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","path":"js/third-party/reveal/math.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","path":"js/third-party/reveal/zoom.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","path":"js/third-party/reveal/reveal.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","path":"js/third-party/reveal/highlight.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/melody/.eslintrc","hash":"2c75ddb670b21591023b2c4f52ecfb02578b5eae","modified":1588090033759},{"_id":"themes/melody/.eslintignore","hash":"719a633358c168ec04b544a5a306fc454471f72f","modified":1588090033758},{"_id":"themes/melody/.gitignore","hash":"371c0a57184696c2069b146fc8ccaa285ca7626c","modified":1588090033762},{"_id":"themes/melody/.travis.demo.yml","hash":"977db46c56f95e0b475326ee7499890aa16bd971","modified":1588090033763},{"_id":"themes/melody/CHANGELOG.md","hash":"1bd1bad3e3450b69f4b303459ddd18c9ec545e9a","modified":1588090033767},{"_id":"themes/melody/LICENSE","hash":"f6ad35196b942786fa91aedc1c0f45bf89de3fd3","modified":1588090033769},{"_id":"themes/melody/FAQ.md","hash":"2e4871193be2bbade191c1064216072cbe61ab72","modified":1588090033768},{"_id":"themes/melody/_config.yml","hash":"06d5f00811b8fc68d2a391180af7cbe8a3b848c9","modified":1588090033771},{"_id":"themes/melody/README.md","hash":"afbc589a9023a2b827f611e880e2b63d573e9d6c","modified":1588090033770},{"_id":"themes/melody/package.json","hash":"ec19e33a67d5ff52d4fb941477fb4c3494f44a07","modified":1588090033823},{"_id":"themes/melody/stylus_format.json","hash":"53008fbf66531953489ab0f2ce166576b7ba1ab7","modified":1588090033898},{"_id":"themes/melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588090033824},{"_id":"source/404/index.md","hash":"f175723264bec7e53716d540c3d623988d46b84a","modified":1588174053470},{"_id":"source/_data/melody.yml","hash":"63befb0371f120a0813ca16bf7f99336587b8d63","modified":1588406588221},{"_id":"source/_posts/Redis数据结构-1.md","hash":"8aba47794fec780c371af838848428ccc1b745c3","modified":1588417844670},{"_id":"source/categories/index.md","hash":"df36239f3e6260a7571d45566a094e093ab0dd2c","modified":1588174057737},{"_id":"source/gallery/index.md","hash":"ee79543d445772931a1198ba3ede4083d3b6d183","modified":1588174049905},{"_id":"source/slides/index.md","hash":"fc1da47d7195ce85703f0d7600d4fa4b4e7034d7","modified":1588174055669},{"_id":"source/tags/index.md","hash":"70d483629567d1bf57c43b17cdc5addf68062a05","modified":1588173467698},{"_id":"themes/melody/.github/ISSUE_TEMPLATE.md","hash":"d1420092142acd3f38c31099934d84bf5c4a4b7c","modified":1588090033762},{"_id":"themes/melody/.vscode/launch.json","hash":"52d28f3455d1e9ff1d7c56316773a77710e89751","modified":1588090033764},{"_id":"themes/melody/.vscode/settings.json","hash":"defe04b1c276769d86dfb931c373595939729e92","modified":1588090033766},{"_id":"themes/melody/languages/default.yml","hash":"4f87bdc1526111b59785f1dce1025435f7ed8e97","modified":1588090033773},{"_id":"themes/melody/languages/en.yml","hash":"4f87bdc1526111b59785f1dce1025435f7ed8e97","modified":1588090033774},{"_id":"themes/melody/languages/zh-Hans.yml","hash":"1868dda88a019692d1993d5ee6b1b854f1da9d88","modified":1588090033774},{"_id":"themes/melody/layout/archive.pug","hash":"f3198ed4d59ca9d0423060a428106a857247a8f8","modified":1588090033777},{"_id":"themes/melody/layout/404.pug","hash":"0ad5d251ba70edad5c04a45d13ca6a8db3bf7b42","modified":1588090033776},{"_id":"themes/melody/layout/category.pug","hash":"27fe85787ee1e4bba75a6eadbf86f7ffc58cb66a","modified":1588090033777},{"_id":"themes/melody/layout/gallery.pug","hash":"1470a86b329eb5c60d6fa6a7bafa25ddf1255f97","modified":1588090033779},{"_id":"themes/melody/layout/index.pug","hash":"d15a36b5c8f1bec367888edb358e70b47eb15ea9","modified":1588090033818},{"_id":"themes/melody/layout/page.pug","hash":"bbcd45cc14b69e260cf7bf851d1926dedc5cd3be","modified":1588090033819},{"_id":"themes/melody/layout/post.pug","hash":"40cb5814e69027ac030792a3b8d72bb43811f8e6","modified":1588090033820},{"_id":"themes/melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1588090033821},{"_id":"themes/melody/layout/tag.pug","hash":"6b5c5c08e9a6773a4fce8583fdf614a784beb045","modified":1588090033822},{"_id":"themes/melody/scripts/gallery-tag.js","hash":"b18e4a809de37da54ea914452ce4a24785fa7621","modified":1588090033824},{"_id":"themes/melody/scripts/replace-config.js","hash":"9d5378898a068e77b5e601c950b631144bd743cf","modified":1588090033826},{"_id":"themes/melody/source/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1588090033896},{"_id":"themes/melody/source/favicon.ico","hash":"af1eb9adcd8e0a46786da960f6a22f3dcab8c819","modified":1588176503764},{"_id":"themes/melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588090033858},{"_id":"themes/melody/layout/includes/additional-js.pug","hash":"92c27adaf87d1108da8ba31c31ceae0e2083484c","modified":1588090033783},{"_id":"themes/melody/layout/includes/config.pug","hash":"42e523fef2e9f285d989d494f0a6fce485921719","modified":1588090033790},{"_id":"themes/melody/layout/includes/footer.pug","hash":"c5968d30a668c3d1b8e658d784b661799d3ba48a","modified":1588090033793},{"_id":"themes/melody/layout/includes/head.pug","hash":"5c5ad5baa1d44bd4264cc1af0042123ace8aa853","modified":1588090033796},{"_id":"themes/melody/layout/includes/header.pug","hash":"2d6ab2df1c048654c5b32eeed789e19949853d93","modified":1588090033796},{"_id":"themes/melody/layout/includes/layout.pug","hash":"80e59c4023baa2504bff0e9a69efab3314f8ffdb","modified":1588090033798},{"_id":"themes/melody/layout/includes/nav.pug","hash":"e1f5053a66a48b6fb6c4390ae55f5bd8e397ff8e","modified":1588090033801},{"_id":"themes/melody/layout/includes/recent-posts.pug","hash":"f37dc3576cc45ad3da097b58f420b5b523d8a9a5","modified":1588090033804},{"_id":"themes/melody/layout/includes/pagination.pug","hash":"11a7d975f7e44932ea509a1a9d29f3e1ddece73e","modified":1588090033803},{"_id":"themes/melody/layout/includes/sidebar.pug","hash":"5fd5e002d0ab203489c840451e4fa9d3535610e2","modified":1588090033810},{"_id":"themes/melody/source/css/404.styl","hash":"e16201381c7f064f1923a12a23136cec6db0a8a0","modified":1588090033828},{"_id":"themes/melody/source/css/index.styl","hash":"c2823ad6013df237993eea5cf190c313270da4db","modified":1588090033849},{"_id":"themes/melody/source/css/var.styl","hash":"bfce8a6dd838762e3db0b0052887220eb260dc7b","modified":1588090033851},{"_id":"themes/melody/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1588090033852},{"_id":"themes/melody/source/js/fireworks.js","hash":"f4f902392525133028f501bef2afa6b1045b5b9c","modified":1588090033856},{"_id":"themes/melody/source/js/copy.js","hash":"a3a7c3158ea23a3bf63f7900750cc0928b73e25f","modified":1588090033855},{"_id":"themes/melody/source/js/fancybox.js","hash":"91d2acc362c03d905b2d40bda42e08c0ae81c4f7","modified":1588090033856},{"_id":"themes/melody/source/js/head.js","hash":"24bc79d4382730d79174cdc2cd3de6368dee8034","modified":1588090033857},{"_id":"themes/melody/source/js/katex.js","hash":"8cc3bcbfd489f86714e815dc6ab8bad466c49664","modified":1588090033860},{"_id":"themes/melody/source/js/scroll.js","hash":"ec2d51d4c98af4e1162a79e430340a7aeb3a7165","modified":1588090033861},{"_id":"themes/melody/source/js/sidebar.js","hash":"6906dcca3a6b9bd46489ca378bc1e74e454168ac","modified":1588090033865},{"_id":"themes/melody/source/js/transition.js","hash":"24db2b0ae93ea925fb18be6d466365a4cd9f6576","modified":1588090033894},{"_id":"themes/melody/source/js/utils.js","hash":"5ff6609b1d674f7879f30e491bdd3c69139704da","modified":1588090033895},{"_id":"themes/melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588090033795},{"_id":"themes/melody/source/img/avatar.png","hash":"af1eb9adcd8e0a46786da960f6a22f3dcab8c819","modified":1588176503764},{"_id":"themes/melody/layout/includes/404/404-nav.pug","hash":"f085a65214c2656ef6a104a2ae9fa1f8fbc196c1","modified":1588090033780},{"_id":"themes/melody/layout/includes/404/layout.pug","hash":"24e9cee9d7c96712fffc404671d88f1d9c0a5a9b","modified":1588090033782},{"_id":"themes/melody/layout/includes/comments/gitalk.pug","hash":"590bc5af43bc55182157dbac65e7cd8bf39f410d","modified":1588090033786},{"_id":"themes/melody/layout/includes/comments/disqus.pug","hash":"0d753ace1190deebd9173279ab5369e4a30c53a8","modified":1588090033785},{"_id":"themes/melody/layout/includes/comments/gitment.pug","hash":"97f524092775c9b7e618c691df40b4bce9e121ac","modified":1588090033786},{"_id":"themes/melody/layout/includes/comments/index.pug","hash":"b8c1344a2760a46774f1894967c879d72802556d","modified":1588090033787},{"_id":"themes/melody/layout/includes/comments/laibili.pug","hash":"1ffb80147fd443144ca6cf0230515f229eba6745","modified":1588090033788},{"_id":"themes/melody/layout/includes/comments/valine.pug","hash":"81e10998d5a2d28857f1c32e2d8b1ba1d84ce0f8","modified":1588090033790},{"_id":"themes/melody/layout/includes/count/busuanzi.pug","hash":"760be9ea92e5eb6959f37b76b9c13fb627893b0a","modified":1588090033792},{"_id":"themes/melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1588090033794},{"_id":"themes/melody/layout/includes/mixins/article-sort.pug","hash":"05c080cbd236b7d94765350cc699b92736ca4609","modified":1588090033799},{"_id":"themes/melody/layout/includes/mixins/slide.pug","hash":"cde884e97dd980bf05910934ce1d52ef3bd5df9c","modified":1588090033801},{"_id":"themes/melody/layout/includes/search/index.pug","hash":"66b4f4e8119e987cd3f9907298689a1408a05859","modified":1588090033805},{"_id":"themes/melody/layout/includes/search/algolia.pug","hash":"3d2b2de0e199ab1fb151f41f2bbaac909f3d3d12","modified":1588090033805},{"_id":"themes/melody/layout/includes/search/local-search.pug","hash":"205aff585f7763b61b8597c6121e6d8c5f9329a4","modified":1588090033806},{"_id":"themes/melody/layout/includes/share/add-this.pug","hash":"055d41a0cc135b8fb02da8faa1df5faacb8fc13d","modified":1588090033808},{"_id":"themes/melody/layout/includes/share/index.pug","hash":"42794c93723016ce1f23b81325e723a6f23f72d0","modified":1588090033809},{"_id":"themes/melody/layout/includes/share/share-js.pug","hash":"c1ab921b1874d0026a7e1c23833600e3ea158881","modified":1588090033809},{"_id":"themes/melody/layout/includes/slide/script.pug","hash":"cacee97b98943fecc3ad50c1b45f71a4cf2e8c4b","modified":1588090033814},{"_id":"themes/melody/layout/includes/slide/layout.pug","hash":"171ce0b25aad4f5f4095f5da0caa7e9d26664a03","modified":1588090033813},{"_id":"themes/melody/layout/includes/third-party/canvas-ribbon.pug","hash":"a72c4b5943e9e88588983ab1c1cfeaf210142c56","modified":1588090033815},{"_id":"themes/melody/layout/includes/third-party/katex.pug","hash":"19ffed43fa22c3bf1c8d974a8d33f73a9a67d098","modified":1588090033815},{"_id":"themes/melody/layout/includes/third-party/mathjax.pug","hash":"0afc0e488ef64f5cb27b9fc90b13f0f9e9f958a5","modified":1588090033816},{"_id":"themes/melody/source/css/_highlight/diff.styl","hash":"4e761f65c28f9df474fa2bd4d891c22db1aafa27","modified":1588090033831},{"_id":"themes/melody/source/css/_global/index.styl","hash":"a6ad6d2675e975883855a1fa3a634c7ba06d4685","modified":1588090033830},{"_id":"themes/melody/source/css/_highlight/highlight.styl","hash":"ca5913698ddd97a55adcc98097038e4190cd7b58","modified":1588090033833},{"_id":"themes/melody/source/css/_layout/comments.styl","hash":"3b32040e894978ec9be6569f44fd5557734f2340","modified":1588090033835},{"_id":"themes/melody/source/css/_highlight/theme.styl","hash":"89af8e4eb6adacee6693b3df46d87a0b1b2b0d2d","modified":1588090033834},{"_id":"themes/melody/source/css/_layout/footer.styl","hash":"cb6db6151a49db6af0f7f6c8ee4c84872a75e437","modified":1588090033836},{"_id":"themes/melody/source/css/_layout/head.styl","hash":"41fe374cfa854be779b07d91f918836e8c03d54a","modified":1588090033837},{"_id":"themes/melody/source/css/_layout/page.styl","hash":"65420e8415cc117916c8b13f214d3a76815692dd","modified":1588090033839},{"_id":"themes/melody/source/css/_layout/pagination.styl","hash":"ad5dc99b438588f92115592ed2d65a47c980720d","modified":1588090033840},{"_id":"themes/melody/source/css/_layout/post.styl","hash":"01e135d129bb66f278039f6d2780e4462319395a","modified":1588090033841},{"_id":"themes/melody/source/css/_layout/sidebar.styl","hash":"29b02d3c319d84ab98dddec449f4bc83fbfdad36","modified":1588090033842},{"_id":"themes/melody/source/css/_search/algolia.styl","hash":"0168c78d28fbc8996ad9e1764457a6526404515b","modified":1588090033843},{"_id":"themes/melody/source/css/_search/index.styl","hash":"b16e4c15ad5844096f427eb3bdb49c5bb0bbcaf7","modified":1588090033844},{"_id":"themes/melody/source/css/_search/local-search.styl","hash":"adb2663fcfee1c84461231472f228aa82c6478bd","modified":1588090033845},{"_id":"themes/melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1588090033848},{"_id":"themes/melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1588090033849},{"_id":"themes/melody/source/js/search/local-search.js","hash":"a642a93fb52ebc87f05e5d3cee38618013fda539","modified":1588090033864},{"_id":"themes/melody/source/js/search/algolia.js","hash":"8a6673cb1616b50a5ac8b2dc20fb3475bc32039f","modified":1588090033862},{"_id":"themes/melody/source/js/third-party/canvas-ribbon.js","hash":"48abc9e33d90de08a49d63e1bcd21defe0461309","modified":1588090033868},{"_id":"themes/melody/source/js/third-party/anime.min.js","hash":"7c9416c1b444773b2d82e797131d6047364645a3","modified":1588090033867},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","hash":"0acabccbb20d722141fa15b37d535807092b2c88","modified":1588090033870},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1588090033894},{"_id":"themes/melody/source/js/third-party/velocity.min.js","hash":"15a9dc404e02f2cd9b46cc71293b65671976567b","modified":1588090033893},{"_id":"themes/melody/source/js/third-party/jquery.min.js","hash":"67bdacbd077ee59f411109fd119ee9f58db15a5f","modified":1588090033873},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","hash":"e34a3faf6e51034de612d15700e059fe82dba310","modified":1588090033874},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1588090033886},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","hash":"abd5391551b7b4e0cc0511c4b5c5ccfe66100f1b","modified":1588090033887},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1588090033889},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1588090033888},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1588090033892},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1588090033891},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1588090033884},{"_id":"public/search.xml","hash":"6b7905965641a88f9e6575bf9ace1e64494dd55f","modified":1601034419374},{"_id":"public/404.html","hash":"32c04b1bc5307fe8e53fe6407fb088c49b1b3e76","modified":1601034419374},{"_id":"public/categories/index.html","hash":"da953c43f40eec41a013dc2577eb2445a6409329","modified":1601034419374},{"_id":"public/gallery/index.html","hash":"44a88ae225242ea1e77d8a6d549a13ad37c8d0ea","modified":1601034419374},{"_id":"public/slides/index.html","hash":"c594725b7dc9bb7ffb9ebe09024b5aecce7e80cb","modified":1601034419374},{"_id":"public/tags/index.html","hash":"3ac7252ff6e7d8959152ce3b89e3c841e75e1309","modified":1601034419374},{"_id":"public/archives/index.html","hash":"43e55974257fd99b430deca91534d737ba3014e3","modified":1601034419374},{"_id":"public/archives/2020/index.html","hash":"4df5d82743a7c75c35dbf3d86379c67c58d3ff46","modified":1601034419374},{"_id":"public/archives/2020/04/index.html","hash":"703e072e131ac4eb65df15baa4a5068cbb953ac5","modified":1601034419374},{"_id":"public/categories/redis源码/index.html","hash":"11d1ea6030e57211d4766e8f00a320737e775716","modified":1601034419374},{"_id":"public/index.html","hash":"583bdc129da057b88beec9802d4b884130c985a3","modified":1601034419374},{"_id":"public/tags/redis/index.html","hash":"6a63cb3380785f1b6274fac54896c25947da50a2","modified":1601034419374},{"_id":"public/2020/04/30/Redis数据结构-1/index.html","hash":"e55bc09faf181a2f0dcff011ffcb49ba051e1a65","modified":1601034419374},{"_id":"public/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1601034419374},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1601034419374},{"_id":"public/favicon.ico","hash":"af1eb9adcd8e0a46786da960f6a22f3dcab8c819","modified":1601034419374},{"_id":"public/img/avatar.png","hash":"af1eb9adcd8e0a46786da960f6a22f3dcab8c819","modified":1601034419374},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1601034419374},{"_id":"public/css/404.css","hash":"712ecbf4ac203ab5f1ea92989c0f0062a3d0aca9","modified":1601034419374},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1601034419374},{"_id":"public/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1601034419374},{"_id":"public/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1601034419374},{"_id":"public/js/fireworks.js","hash":"17d5770d46d9b531b675b129835561146290af83","modified":1601034419374},{"_id":"public/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1601034419374},{"_id":"public/js/scroll.js","hash":"467f883ca2ace0c0fb46ae24919223560a6fb72c","modified":1601034419374},{"_id":"public/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1601034419374},{"_id":"public/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1601034419374},{"_id":"public/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1601034419374},{"_id":"public/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1601034419374},{"_id":"public/js/search/local-search.js","hash":"b7e77c27097d9d3ced13618912069d1ddf1cd64a","modified":1601034419374},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1601034419374},{"_id":"public/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1601034419374},{"_id":"public/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1601034419374},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1601034419374},{"_id":"public/js/third-party/reveal/head.min.js","hash":"95c9de30444117adbbb3218070fda00af187a76a","modified":1601034419374},{"_id":"public/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1601034419374},{"_id":"public/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1601034419374},{"_id":"public/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1601034419374},{"_id":"public/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1601034419374},{"_id":"public/css/index.css","hash":"76df2b0a1b49c203be5f25ad0d54e4361610496a","modified":1601034419374},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1601034419374},{"_id":"public/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1601034419374},{"_id":"public/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1601034419374},{"_id":"public/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1601034419374},{"_id":"public/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1601034419374},{"_id":"public/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1601034419374}],"Category":[{"name":"redis源码","_id":"ckfi6k1aw0002z4wjdu6bdjmu"}],"Data":[{"_id":"melody","data":{"theme_color":{"enable":true,"main":"#49B1F5","paginator":"#00C4B6","button_hover":"#FF7242","text_selection":"#00C4B6","link_color":"#858585","hr_color":"#A4D8FA","tag_start_color":"#A4D8FA","tag_end_color":"#1B9EF3","header_text_color":"#EEEEEE","footer_text_color":"#EEEEEE"},"menu":{"Home":"/","Tags":"/tags","Categories":"/categories"},"favicon":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/favicon.png","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"social":{"github fa":"https://github.com/LittleMeepo"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":true,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"},"hide_scrollbar":true},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/avatar.jpg","top_img":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/banner/0.jpg","top_img_height":80,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"league","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2019,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file\"></i>","page_pv_footer":null},"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false},"follow":{"enable":false,"url":"","text":""},"sidebar_display":"post","google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"disable_baidu_transformation":true,"404Text":null}}],"Page":[{"title":"404","date":"2019-10-13T07:49:05.000Z","layout":"404","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2019-10-13 15:49:05\nlayout: 404\npermalink: /404\n---","updated":"2020-04-29T15:27:33.470Z","path":"/404.html","comments":1,"_id":"ckfi6k1ah0000z4wj75l397yw","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#49B1F5","paginator":"#00C4B6","button_hover":"#FF7242","text_selection":"#00C4B6","link_color":"#858585","hr_color":"#A4D8FA","tag_start_color":"#A4D8FA","tag_end_color":"#1B9EF3","header_text_color":"#EEEEEE","footer_text_color":"#EEEEEE"},"menu":{"Home":"/","Tags":"/tags","Categories":"/categories"},"favicon":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/favicon.png","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"social":{"github fa":"https://github.com/LittleMeepo"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":true,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"},"hide_scrollbar":true},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/avatar.jpg","top_img":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/banner/0.jpg","top_img_height":80,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"league","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2019,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file\"></i>","page_pv_footer":null},"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false},"follow":{"enable":false,"url":"","text":""},"sidebar_display":"post","google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"disable_baidu_transformation":true,"404Text":null,"rootConfig":{"title":"Edith","subtitle":"Even dead, I'm the Hero.","description":"Wang's blog","author":"Wang","language":"zh-Hans","timezone":"","url":"https://wfc.ink","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":true,"trailing_html":true},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":"","wrap":true,"hljs":false},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"melody","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":[{"type":"git","repo":"git@106.54.209.155:/home/git/blog.git","branch":"master"}],"ignore":null,"meta_generator":true,"keywords":["C++","Linux"],"index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"search":{"path":"search.xml","field":"post","content":true},"markdown_it_plus":{"plugins":[{"plugin":null,"name":"@neilsustc/markdown-it-katex","enable":true,"options":{"strict":false}}]},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10}}}}},"excerpt":"","more":""},{"title":"分类","date":"2018-01-04T16:00:00.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\n---","updated":"2020-04-29T15:27:37.737Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckfi6k35s0006z4wjcnfq7jbq","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#49B1F5","paginator":"#00C4B6","button_hover":"#FF7242","text_selection":"#00C4B6","link_color":"#858585","hr_color":"#A4D8FA","tag_start_color":"#A4D8FA","tag_end_color":"#1B9EF3","header_text_color":"#EEEEEE","footer_text_color":"#EEEEEE"},"menu":{"Home":"/","Tags":"/tags","Categories":"/categories"},"favicon":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/favicon.png","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"social":{"github fa":"https://github.com/LittleMeepo"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":true,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"},"hide_scrollbar":true},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/avatar.jpg","top_img":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/banner/0.jpg","top_img_height":80,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"league","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2019,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file\"></i>","page_pv_footer":null},"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false},"follow":{"enable":false,"url":"","text":""},"sidebar_display":"post","google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"disable_baidu_transformation":true,"404Text":null,"rootConfig":{"title":"Edith","subtitle":"Even dead, I'm the Hero.","description":"Wang's blog","author":"Wang","language":"zh-Hans","timezone":"","url":"https://wfc.ink","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":true,"trailing_html":true},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":"","wrap":true,"hljs":false},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"melody","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":[{"type":"git","repo":"git@106.54.209.155:/home/git/blog.git","branch":"master"}],"ignore":null,"meta_generator":true,"keywords":["C++","Linux"],"index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"search":{"path":"search.xml","field":"post","content":true},"markdown_it_plus":{"plugins":[{"plugin":null,"name":"@neilsustc/markdown-it-katex","enable":true,"options":{"strict":false}}]},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10}}}}},"excerpt":"","more":""},{"title":"Gallery","date":"2018-01-04T16:00:00.000Z","type":"gallery","_content":"","source":"gallery/index.md","raw":"---\ntitle: Gallery\ndate: 2018-01-05 00:00:00\ntype: \"gallery\"\n---","updated":"2020-04-29T15:27:29.905Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"ckfi6k35t0007z4wjh6xuh8ci","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#49B1F5","paginator":"#00C4B6","button_hover":"#FF7242","text_selection":"#00C4B6","link_color":"#858585","hr_color":"#A4D8FA","tag_start_color":"#A4D8FA","tag_end_color":"#1B9EF3","header_text_color":"#EEEEEE","footer_text_color":"#EEEEEE"},"menu":{"Home":"/","Tags":"/tags","Categories":"/categories"},"favicon":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/favicon.png","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"social":{"github fa":"https://github.com/LittleMeepo"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":true,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"},"hide_scrollbar":true},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/avatar.jpg","top_img":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/banner/0.jpg","top_img_height":80,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"league","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2019,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file\"></i>","page_pv_footer":null},"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false},"follow":{"enable":false,"url":"","text":""},"sidebar_display":"post","google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"disable_baidu_transformation":true,"404Text":null,"rootConfig":{"title":"Edith","subtitle":"Even dead, I'm the Hero.","description":"Wang's blog","author":"Wang","language":"zh-Hans","timezone":"","url":"https://wfc.ink","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":true,"trailing_html":true},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":"","wrap":true,"hljs":false},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"melody","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":[{"type":"git","repo":"git@106.54.209.155:/home/git/blog.git","branch":"master"}],"ignore":null,"meta_generator":true,"keywords":["C++","Linux"],"index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"search":{"path":"search.xml","field":"post","content":true},"markdown_it_plus":{"plugins":[{"plugin":null,"name":"@neilsustc/markdown-it-katex","enable":true,"options":{"strict":false}}]},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10}}}}},"excerpt":"","more":""},{"title":"Slides","date":"2018-01-04T16:00:00.000Z","type":"slides","_content":"","source":"slides/index.md","raw":"---\ntitle: Slides\ndate: 2018-01-05 00:00:00\ntype: \"slides\"\n---","updated":"2020-04-29T15:27:35.669Z","path":"slides/index.html","comments":1,"layout":"page","_id":"ckfi6k35v0008z4wjegxba5qz","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#49B1F5","paginator":"#00C4B6","button_hover":"#FF7242","text_selection":"#00C4B6","link_color":"#858585","hr_color":"#A4D8FA","tag_start_color":"#A4D8FA","tag_end_color":"#1B9EF3","header_text_color":"#EEEEEE","footer_text_color":"#EEEEEE"},"menu":{"Home":"/","Tags":"/tags","Categories":"/categories"},"favicon":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/favicon.png","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"social":{"github fa":"https://github.com/LittleMeepo"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":true,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"},"hide_scrollbar":true},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/avatar.jpg","top_img":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/banner/0.jpg","top_img_height":80,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"league","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2019,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file\"></i>","page_pv_footer":null},"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false},"follow":{"enable":false,"url":"","text":""},"sidebar_display":"post","google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"disable_baidu_transformation":true,"404Text":null,"rootConfig":{"title":"Edith","subtitle":"Even dead, I'm the Hero.","description":"Wang's blog","author":"Wang","language":"zh-Hans","timezone":"","url":"https://wfc.ink","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":true,"trailing_html":true},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":"","wrap":true,"hljs":false},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"melody","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":[{"type":"git","repo":"git@106.54.209.155:/home/git/blog.git","branch":"master"}],"ignore":null,"meta_generator":true,"keywords":["C++","Linux"],"index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"search":{"path":"search.xml","field":"post","content":true},"markdown_it_plus":{"plugins":[{"plugin":null,"name":"@neilsustc/markdown-it-katex","enable":true,"options":{"strict":false}}]},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10}}}}},"excerpt":"","more":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\n---","updated":"2020-04-29T15:17:47.698Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckfi6k35w0009z4wjfs331fyr","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#49B1F5","paginator":"#00C4B6","button_hover":"#FF7242","text_selection":"#00C4B6","link_color":"#858585","hr_color":"#A4D8FA","tag_start_color":"#A4D8FA","tag_end_color":"#1B9EF3","header_text_color":"#EEEEEE","footer_text_color":"#EEEEEE"},"menu":{"Home":"/","Tags":"/tags","Categories":"/categories"},"favicon":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/favicon.png","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"social":{"github fa":"https://github.com/LittleMeepo"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":true,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"},"hide_scrollbar":true},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/avatar.jpg","top_img":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/banner/0.jpg","top_img_height":80,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"league","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2019,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file\"></i>","page_pv_footer":null},"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false},"follow":{"enable":false,"url":"","text":""},"sidebar_display":"post","google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"disable_baidu_transformation":true,"404Text":null,"rootConfig":{"title":"Edith","subtitle":"Even dead, I'm the Hero.","description":"Wang's blog","author":"Wang","language":"zh-Hans","timezone":"","url":"https://wfc.ink","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":true,"trailing_html":true},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":"","wrap":true,"hljs":false},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"melody","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":[{"type":"git","repo":"git@106.54.209.155:/home/git/blog.git","branch":"master"}],"ignore":null,"meta_generator":true,"keywords":["C++","Linux"],"index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"search":{"path":"search.xml","field":"post","content":true},"markdown_it_plus":{"plugins":[{"plugin":null,"name":"@neilsustc/markdown-it-katex","enable":true,"options":{"strict":false}}]},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10}}}}},"excerpt":"","more":""}],"Post":[{"title":"redis数据结构-1","date":"2020-04-30T14:56:00.000Z","_content":"\n## 简单动态字符串sds\nsds 的源码主要在 sds.h 和 sds.c 中\n\n``` c\n/*\n * 保存字符串对象的结构\n */\nstruct sdshdr {\n    \n    // buf 中已占用空间的长度\n    int len;\n\n    // buf 中剩余可用空间的长度\n    int free;\n\n    // 数据空间\n    char buf[];\n};\n```\n其中 buf 数组是柔性数组，在分配的时候不占内存大小\n\nsds.h 中还有两个 inline 的静态函数，用于返回实际保存的字符串长度和可用空间的字符串长度\n``` c\n/*\n * 返回 sds 实际保存的字符串的长度\n */\nstatic inline size_t sdslen(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); //buf地址往回sizeof(struct sdshdr))\n    return sh->len;\n}\n```\n\n``` c\n/*\n * 返回 sds 可用空间的长度\n */\nstatic inline size_t sdsavail(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    return sh->free;\n}\n```\n这边用了一个骚操作，用 buf 的数组指针减去8字节，就得到了结构体的初始位置，也就是结构体的指针：\n<div align='center'>\n  <img src=\"https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/redis/20200502162607.png\" height=\"180px\">\n</div>\n这个技巧在 redis 中多处用到\n\nsds 主要接口函数声明：\n``` c\n// 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 sds T = O(N)\nsds sdsnewlen(const void *init, size_t initlen);\n\n// 根据给定字符串 init ，创建一个包含同样字符串的 sds T = O(N)\nsds sdsnew(const char *init);\n\n// 创建并返回一个只保存了空字符串 \"\" 的 sds T = O(1)\nsds sdsempty(void);\n\n// 返回 sds 实际保存的字符串的长度 T = O(1)\nsize_t sdslen(const sds s);\n\n// 复制给定 sds 的副本 T = O(N)\nsds sdsdup(const sds s);\n\n// 释放给定的 sds T = O(N)\nvoid sdsfree(sds s);\n\n// 返回 sds 可用空间的长度 T = O(1)\nsize_t sdsavail(const sds s);\n\n// 将 sds 扩充至指定长度，未使用的空间以 0 字节填充 T = O(N)\nsds sdsgrowzero(sds s, size_t len);\n\n// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 T = O(N)\nsds sdscatlen(sds s, const void *t, size_t len);\n\n// 将给定字符串 t 追加到 sds 的末尾 T = O(N)\nsds sdscat(sds s, const char *t);\n\n// 将另一个 sds 追加到一个 sds 的末尾 T = O(N)\nsds sdscatsds(sds s, const sds t);\n\n// 将字符串 t 的前 len 个字符复制到 sds s 当中，并在字符串的最后添加终结符 T = O(N)\nsds sdscpylen(sds s, const char *t, size_t len);\n\n// 将字符串复制到 sds 当中，覆盖原有的字符 T = O(N)\nsds sdscpy(sds s, const char *t);\n```\n\n其中几个：\n- **sdsnew**   \n  根据给定字符串 init ，创建一个包含同样字符串的 sds\n``` c\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n```\n其中调用了：\n- **sdsnewlen**   \n  根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的\n``` c\nsds sdsnewlen(const void *init, size_t initlen) {\n\n    struct sdshdr *sh;\n\n    // 根据是否有初始化内容，选择适当的内存分配方式\n    if (init) {\n        // zmalloc 不初始化所分配的内存\n        sh = zmalloc(sizeof(struct sdshdr)+initlen+1); // 结构体+buf数组+'\\0'\n    } else {\n        // zcalloc 将分配的内存全部初始化为 0\n        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);\n    }\n\n    // 内存分配失败，返回\n    if (sh == NULL) return NULL;\n\n    // 设置初始化长度\n    sh->len = initlen;\n    // 新 sds 不预留任何空间\n    sh->free = 0;\n    // 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中\n    // T = O(N)\n    if (initlen && init)\n        memcpy(sh->buf, init, initlen);\n    // 以 \\0 结尾\n    sh->buf[initlen] = '\\0';\n\n    // 返回 buf 部分，而不是整个 sdshdr\n    return (char*)sh->buf;\n}\n```\n其中 zmalloc 和 zcalloc 为 redis 使用的内存管理工具，在 zmalloc.c 和 zmalloc.h 中定义\n\n## 双端链表\n双端链表 的源码主要在 adlist.h 和 adlist.c 中\n\n双端链表节点：\n``` c\n/*\n * 双端链表节点\n */\ntypedef struct listNode {\n\n    // 前置节点\n    struct listNode *prev;\n\n    // 后置节点\n    struct listNode *next;\n\n    // 节点的值\n    void *value;\n\n} listNode;\n```\n\n双端链表结构:\n``` c\n/*\n * 双端链表结构\n */\ntypedef struct list {\n\n    // 表头节点\n    listNode *head;\n\n    // 表尾节点\n    listNode *tail;\n\n    // 节点值复制函数\n    void *(*dup)(void *ptr);\n\n    // 节点值释放函数\n    void (*free)(void *ptr);\n\n    // 节点值对比函数\n    int (*match)(void *ptr, void *key);\n\n    // 链表所包含的节点数量\n    unsigned long len;\n\n} list;\n```\n\n为了规范化的宏定义函数：\n``` c\n// 返回给定链表所包含的节点数量\n// T = O(1)\n#define listLength(l) ((l)->len)\n// 返回给定链表的表头节点\n// T = O(1)\n#define listFirst(l) ((l)->head)\n// 返回给定链表的表尾节点\n// T = O(1)\n#define listLast(l) ((l)->tail)\n// 返回给定节点的前置节点\n// T = O(1)\n#define listPrevNode(n) ((n)->prev)\n// 返回给定节点的后置节点\n// T = O(1)\n#define listNextNode(n) ((n)->next)\n// 返回给定节点的值\n// T = O(1)\n#define listNodeValue(n) ((n)->value)\n\n// 将链表 l 的值复制函数设置为 m\n// T = O(1)\n#define listSetDupMethod(l,m) ((l)->dup = (m))\n// 将链表 l 的值释放函数设置为 m\n// T = O(1)\n#define listSetFreeMethod(l,m) ((l)->free = (m))\n// 将链表的对比函数设置为 m\n// T = O(1)\n#define listSetMatchMethod(l,m) ((l)->match = (m))\n\n// 返回给定链表的值复制函数\n// T = O(1)\n#define listGetDupMethod(l) ((l)->dup)\n// 返回给定链表的值释放函数\n// T = O(1)\n#define listGetFree(l) ((l)->free)\n// 返回给定链表的值对比函数\n// T = O(1)\n#define listGetMatchMethod(l) ((l)->match)\n```\n\n几个主要接口函数：\n- **listCreate**  \n  创建一个新的链表 T = O(1)\n``` c\nlist *listCreate(void)\n{\n    struct list *list;\n\n    // 分配内存\n    if ((list = zmalloc(sizeof(*list))) == NULL)\n        return NULL;\n\n    // 初始化属性\n    list->head = list->tail = NULL;\n    list->len = 0;\n    list->dup = NULL;\n    list->free = NULL;\n    list->match = NULL;\n\n    return list;\n}\n```\n- **listRelease**  \n  释放整个链表，以及链表中所有节点\n``` c\nvoid listRelease(list *list)\n{\n    unsigned long len;\n    listNode *current, *next;\n\n    // 指向头指针\n    current = list->head;\n    // 遍历整个链表\n    len = list->len;\n    while(len--) {\n        next = current->next;\n\n        // 如果有设置值释放函数，那么调用它\n        if (list->free) list->free(current->value);\n\n        // 释放节点结构\n        zfree(current);\n\n        current = next;\n    }\n\n    // 释放链表结构\n    zfree(list);\n}\n```\n\n- **listAddNodeHead**  \n  将一个包含有给定值指针 value 的新节点添加到链表的表头\n``` c\nlist *listAddNodeHead(list *list, void *value)\n{\n    listNode *node;\n\n    // 为节点分配内存\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n\n    // 保存值指针\n    node->value = value;\n\n    // 添加节点到空链表\n    if (list->len == 0) {\n        list->head = list->tail = node;\n        node->prev = node->next = NULL;\n    // 添加节点到非空链表\n    } else {\n        node->prev = NULL;\n        node->next = list->head;\n        list->head->prev = node;\n        list->head = node;\n    }\n\n    // 更新链表节点数\n    list->len++;\n\n    return list;\n}\n```\n\n在 redis 双端队列中使用了迭代器这一技巧\n\n双端链表迭代器：\n``` c\n/*\n * 双端链表迭代器\n */\ntypedef struct listIter {\n\n    // 当前迭代到的节点\n    listNode *next;\n\n    // 迭代的方向\n    int direction;\n\n} listIter;\n```\n\n- **listGetIterator**  \n  为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点\n``` c\nlistIter *listGetIterator(list *list, int direction)\n{\n    // 为迭代器分配内存\n    listIter *iter;\n    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;\n\n    // 根据迭代方向，设置迭代器的起始节点\n    if (direction == AL_START_HEAD)\n        iter->next = list->head;\n    else\n        iter->next = list->tail;\n\n    // 记录迭代方向\n    iter->direction = direction;\n\n    return iter;\n}\n```\n\n- **listNext**  \n  返回迭代器当前所指向的节点  \n  这个函数其实有两个作用：返回当前迭代器指向的节点 + 使迭代器指向下一个节点（我刚开始还没明白只return了一个current，怎么把iter传出去，后来看了这个函数的使用才知道，因为函数传入的是指针，只要定义一个listIter类型的指针，一直使用该函数就能迭代了\n``` c\nlistNode *listNext(listIter *iter)\n{\n    listNode *current = iter->next;\n\n    if (current != NULL) {\n        // 根据方向选择下一个节点\n        if (iter->direction == AL_START_HEAD)\n            // 保存下一个节点，防止当前节点被删除而造成指针丢失\n            iter->next = current->next;\n        else\n            // 保存下一个节点，防止当前节点被删除而造成指针丢失\n            iter->next = current->prev;\n    }\n\n    return current;\n}\n```\n\n- **listDup**  \n  复制整个链表  \n  其中就使用了上述的listNext来进行迭代\n``` c\nlist *listDup(list *orig)\n{\n    list *copy;\n    listIter *iter;\n    listNode *node;\n\n    // 创建新链表\n    if ((copy = listCreate()) == NULL)\n        return NULL;\n\n    // 设置节点值处理函数\n    copy->dup = orig->dup;\n    copy->free = orig->free;\n    copy->match = orig->match;\n\n    // 迭代整个输入链表\n    iter = listGetIterator(orig, AL_START_HEAD);\n    while((node = listNext(iter)) != NULL) {\n        void *value;\n\n        // 复制节点值到新节点\n        if (copy->dup) {\n            value = copy->dup(node->value);\n            if (value == NULL) {\n                listRelease(copy);\n                listReleaseIterator(iter);\n                return NULL;\n            }\n        } else\n            value = node->value;\n\n        // 将节点添加到链表\n        if (listAddNodeTail(copy, value) == NULL) {\n            listRelease(copy);\n            listReleaseIterator(iter);\n            return NULL;\n        }\n    }\n\n    // 释放迭代器\n    listReleaseIterator(iter);\n\n    // 返回副本\n    return copy;\n}\n```\n  ","source":"_posts/Redis数据结构-1.md","raw":"---\ntitle: redis数据结构-1\ndate: 2020-4-30 22:56\ntags: redis\ncategories: redis源码\n---\n\n## 简单动态字符串sds\nsds 的源码主要在 sds.h 和 sds.c 中\n\n``` c\n/*\n * 保存字符串对象的结构\n */\nstruct sdshdr {\n    \n    // buf 中已占用空间的长度\n    int len;\n\n    // buf 中剩余可用空间的长度\n    int free;\n\n    // 数据空间\n    char buf[];\n};\n```\n其中 buf 数组是柔性数组，在分配的时候不占内存大小\n\nsds.h 中还有两个 inline 的静态函数，用于返回实际保存的字符串长度和可用空间的字符串长度\n``` c\n/*\n * 返回 sds 实际保存的字符串的长度\n */\nstatic inline size_t sdslen(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); //buf地址往回sizeof(struct sdshdr))\n    return sh->len;\n}\n```\n\n``` c\n/*\n * 返回 sds 可用空间的长度\n */\nstatic inline size_t sdsavail(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    return sh->free;\n}\n```\n这边用了一个骚操作，用 buf 的数组指针减去8字节，就得到了结构体的初始位置，也就是结构体的指针：\n<div align='center'>\n  <img src=\"https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/redis/20200502162607.png\" height=\"180px\">\n</div>\n这个技巧在 redis 中多处用到\n\nsds 主要接口函数声明：\n``` c\n// 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 sds T = O(N)\nsds sdsnewlen(const void *init, size_t initlen);\n\n// 根据给定字符串 init ，创建一个包含同样字符串的 sds T = O(N)\nsds sdsnew(const char *init);\n\n// 创建并返回一个只保存了空字符串 \"\" 的 sds T = O(1)\nsds sdsempty(void);\n\n// 返回 sds 实际保存的字符串的长度 T = O(1)\nsize_t sdslen(const sds s);\n\n// 复制给定 sds 的副本 T = O(N)\nsds sdsdup(const sds s);\n\n// 释放给定的 sds T = O(N)\nvoid sdsfree(sds s);\n\n// 返回 sds 可用空间的长度 T = O(1)\nsize_t sdsavail(const sds s);\n\n// 将 sds 扩充至指定长度，未使用的空间以 0 字节填充 T = O(N)\nsds sdsgrowzero(sds s, size_t len);\n\n// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 T = O(N)\nsds sdscatlen(sds s, const void *t, size_t len);\n\n// 将给定字符串 t 追加到 sds 的末尾 T = O(N)\nsds sdscat(sds s, const char *t);\n\n// 将另一个 sds 追加到一个 sds 的末尾 T = O(N)\nsds sdscatsds(sds s, const sds t);\n\n// 将字符串 t 的前 len 个字符复制到 sds s 当中，并在字符串的最后添加终结符 T = O(N)\nsds sdscpylen(sds s, const char *t, size_t len);\n\n// 将字符串复制到 sds 当中，覆盖原有的字符 T = O(N)\nsds sdscpy(sds s, const char *t);\n```\n\n其中几个：\n- **sdsnew**   \n  根据给定字符串 init ，创建一个包含同样字符串的 sds\n``` c\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n```\n其中调用了：\n- **sdsnewlen**   \n  根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的\n``` c\nsds sdsnewlen(const void *init, size_t initlen) {\n\n    struct sdshdr *sh;\n\n    // 根据是否有初始化内容，选择适当的内存分配方式\n    if (init) {\n        // zmalloc 不初始化所分配的内存\n        sh = zmalloc(sizeof(struct sdshdr)+initlen+1); // 结构体+buf数组+'\\0'\n    } else {\n        // zcalloc 将分配的内存全部初始化为 0\n        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);\n    }\n\n    // 内存分配失败，返回\n    if (sh == NULL) return NULL;\n\n    // 设置初始化长度\n    sh->len = initlen;\n    // 新 sds 不预留任何空间\n    sh->free = 0;\n    // 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中\n    // T = O(N)\n    if (initlen && init)\n        memcpy(sh->buf, init, initlen);\n    // 以 \\0 结尾\n    sh->buf[initlen] = '\\0';\n\n    // 返回 buf 部分，而不是整个 sdshdr\n    return (char*)sh->buf;\n}\n```\n其中 zmalloc 和 zcalloc 为 redis 使用的内存管理工具，在 zmalloc.c 和 zmalloc.h 中定义\n\n## 双端链表\n双端链表 的源码主要在 adlist.h 和 adlist.c 中\n\n双端链表节点：\n``` c\n/*\n * 双端链表节点\n */\ntypedef struct listNode {\n\n    // 前置节点\n    struct listNode *prev;\n\n    // 后置节点\n    struct listNode *next;\n\n    // 节点的值\n    void *value;\n\n} listNode;\n```\n\n双端链表结构:\n``` c\n/*\n * 双端链表结构\n */\ntypedef struct list {\n\n    // 表头节点\n    listNode *head;\n\n    // 表尾节点\n    listNode *tail;\n\n    // 节点值复制函数\n    void *(*dup)(void *ptr);\n\n    // 节点值释放函数\n    void (*free)(void *ptr);\n\n    // 节点值对比函数\n    int (*match)(void *ptr, void *key);\n\n    // 链表所包含的节点数量\n    unsigned long len;\n\n} list;\n```\n\n为了规范化的宏定义函数：\n``` c\n// 返回给定链表所包含的节点数量\n// T = O(1)\n#define listLength(l) ((l)->len)\n// 返回给定链表的表头节点\n// T = O(1)\n#define listFirst(l) ((l)->head)\n// 返回给定链表的表尾节点\n// T = O(1)\n#define listLast(l) ((l)->tail)\n// 返回给定节点的前置节点\n// T = O(1)\n#define listPrevNode(n) ((n)->prev)\n// 返回给定节点的后置节点\n// T = O(1)\n#define listNextNode(n) ((n)->next)\n// 返回给定节点的值\n// T = O(1)\n#define listNodeValue(n) ((n)->value)\n\n// 将链表 l 的值复制函数设置为 m\n// T = O(1)\n#define listSetDupMethod(l,m) ((l)->dup = (m))\n// 将链表 l 的值释放函数设置为 m\n// T = O(1)\n#define listSetFreeMethod(l,m) ((l)->free = (m))\n// 将链表的对比函数设置为 m\n// T = O(1)\n#define listSetMatchMethod(l,m) ((l)->match = (m))\n\n// 返回给定链表的值复制函数\n// T = O(1)\n#define listGetDupMethod(l) ((l)->dup)\n// 返回给定链表的值释放函数\n// T = O(1)\n#define listGetFree(l) ((l)->free)\n// 返回给定链表的值对比函数\n// T = O(1)\n#define listGetMatchMethod(l) ((l)->match)\n```\n\n几个主要接口函数：\n- **listCreate**  \n  创建一个新的链表 T = O(1)\n``` c\nlist *listCreate(void)\n{\n    struct list *list;\n\n    // 分配内存\n    if ((list = zmalloc(sizeof(*list))) == NULL)\n        return NULL;\n\n    // 初始化属性\n    list->head = list->tail = NULL;\n    list->len = 0;\n    list->dup = NULL;\n    list->free = NULL;\n    list->match = NULL;\n\n    return list;\n}\n```\n- **listRelease**  \n  释放整个链表，以及链表中所有节点\n``` c\nvoid listRelease(list *list)\n{\n    unsigned long len;\n    listNode *current, *next;\n\n    // 指向头指针\n    current = list->head;\n    // 遍历整个链表\n    len = list->len;\n    while(len--) {\n        next = current->next;\n\n        // 如果有设置值释放函数，那么调用它\n        if (list->free) list->free(current->value);\n\n        // 释放节点结构\n        zfree(current);\n\n        current = next;\n    }\n\n    // 释放链表结构\n    zfree(list);\n}\n```\n\n- **listAddNodeHead**  \n  将一个包含有给定值指针 value 的新节点添加到链表的表头\n``` c\nlist *listAddNodeHead(list *list, void *value)\n{\n    listNode *node;\n\n    // 为节点分配内存\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n\n    // 保存值指针\n    node->value = value;\n\n    // 添加节点到空链表\n    if (list->len == 0) {\n        list->head = list->tail = node;\n        node->prev = node->next = NULL;\n    // 添加节点到非空链表\n    } else {\n        node->prev = NULL;\n        node->next = list->head;\n        list->head->prev = node;\n        list->head = node;\n    }\n\n    // 更新链表节点数\n    list->len++;\n\n    return list;\n}\n```\n\n在 redis 双端队列中使用了迭代器这一技巧\n\n双端链表迭代器：\n``` c\n/*\n * 双端链表迭代器\n */\ntypedef struct listIter {\n\n    // 当前迭代到的节点\n    listNode *next;\n\n    // 迭代的方向\n    int direction;\n\n} listIter;\n```\n\n- **listGetIterator**  \n  为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点\n``` c\nlistIter *listGetIterator(list *list, int direction)\n{\n    // 为迭代器分配内存\n    listIter *iter;\n    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;\n\n    // 根据迭代方向，设置迭代器的起始节点\n    if (direction == AL_START_HEAD)\n        iter->next = list->head;\n    else\n        iter->next = list->tail;\n\n    // 记录迭代方向\n    iter->direction = direction;\n\n    return iter;\n}\n```\n\n- **listNext**  \n  返回迭代器当前所指向的节点  \n  这个函数其实有两个作用：返回当前迭代器指向的节点 + 使迭代器指向下一个节点（我刚开始还没明白只return了一个current，怎么把iter传出去，后来看了这个函数的使用才知道，因为函数传入的是指针，只要定义一个listIter类型的指针，一直使用该函数就能迭代了\n``` c\nlistNode *listNext(listIter *iter)\n{\n    listNode *current = iter->next;\n\n    if (current != NULL) {\n        // 根据方向选择下一个节点\n        if (iter->direction == AL_START_HEAD)\n            // 保存下一个节点，防止当前节点被删除而造成指针丢失\n            iter->next = current->next;\n        else\n            // 保存下一个节点，防止当前节点被删除而造成指针丢失\n            iter->next = current->prev;\n    }\n\n    return current;\n}\n```\n\n- **listDup**  \n  复制整个链表  \n  其中就使用了上述的listNext来进行迭代\n``` c\nlist *listDup(list *orig)\n{\n    list *copy;\n    listIter *iter;\n    listNode *node;\n\n    // 创建新链表\n    if ((copy = listCreate()) == NULL)\n        return NULL;\n\n    // 设置节点值处理函数\n    copy->dup = orig->dup;\n    copy->free = orig->free;\n    copy->match = orig->match;\n\n    // 迭代整个输入链表\n    iter = listGetIterator(orig, AL_START_HEAD);\n    while((node = listNext(iter)) != NULL) {\n        void *value;\n\n        // 复制节点值到新节点\n        if (copy->dup) {\n            value = copy->dup(node->value);\n            if (value == NULL) {\n                listRelease(copy);\n                listReleaseIterator(iter);\n                return NULL;\n            }\n        } else\n            value = node->value;\n\n        // 将节点添加到链表\n        if (listAddNodeTail(copy, value) == NULL) {\n            listRelease(copy);\n            listReleaseIterator(iter);\n            return NULL;\n        }\n    }\n\n    // 释放迭代器\n    listReleaseIterator(iter);\n\n    // 返回副本\n    return copy;\n}\n```\n  ","slug":"Redis数据结构-1","published":1,"updated":"2020-05-02T11:10:44.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi6k1ao0001z4wj45sp2fov","content":"<h2 id=\"简单动态字符串sds\"><a class=\"markdownIt-Anchor\" href=\"#简单动态字符串sds\"></a> 简单动态字符串sds</h2>\n<p>sds 的源码主要在 sds.h 和 sds.c 中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 保存字符串对象的结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// buf 中已占用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf 中剩余可用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据空间</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其中 buf 数组是柔性数组，在分配的时候不占内存大小</p>\n<p>sds.h 中还有两个 inline 的静态函数，用于返回实际保存的字符串长度和可用空间的字符串长度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">sdslen</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span> <span class=\"comment\">//buf地址往回sizeof(struct sdshdr))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sh-&gt;len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回 sds 可用空间的长度</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">sdsavail</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sh-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这边用了一个骚操作，用 buf 的数组指针减去8字节，就得到了结构体的初始位置，也就是结构体的指针：</p>\n<div align='center'>\n  <img src=\"https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/redis/20200502162607.png\" height=\"180px\">\n</div>\n这个技巧在 redis 中多处用到\n<p>sds 主要接口函数声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 sds T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据给定字符串 init ，创建一个包含同样字符串的 sds T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并返回一个只保存了空字符串 \"\" 的 sds T = O(1)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsempty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回 sds 实际保存的字符串的长度 T = O(1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">sdslen</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制给定 sds 的副本 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsdup</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放给定的 sds T = O(N)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sdsfree</span><span class=\"params\">(sds s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回 sds 可用空间的长度 T = O(1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">sdsavail</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 sds 扩充至指定长度，未使用的空间以 0 字节填充 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsgrowzero</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatlen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *t, <span class=\"keyword\">size_t</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将给定字符串 t 追加到 sds 的末尾 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscat</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将另一个 sds 追加到一个 sds 的末尾 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatsds</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> sds t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将字符串 t 的前 len 个字符复制到 sds s 当中，并在字符串的最后添加终结符 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscpylen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t, <span class=\"keyword\">size_t</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将字符串复制到 sds 当中，覆盖原有的字符 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscpy</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>其中几个：</p>\n<ul>\n<li><strong>sdsnew</strong><br />\n根据给定字符串 init ，创建一个包含同样字符串的 sds</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> initlen = (init == <span class=\"literal\">NULL</span>) ? <span class=\"number\">0</span> : <span class=\"built_in\">strlen</span>(init);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(init, initlen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中调用了：</p>\n<ul>\n<li><strong>sdsnewlen</strong><br />\n根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (init) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// zmalloc 不初始化所分配的内存</span></span><br><span class=\"line\">        sh = zmalloc(<span class=\"keyword\">sizeof</span>(struct sdshdr)+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 结构体+buf数组+'\\0'</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class=\"line\">        sh = zcalloc(<span class=\"keyword\">sizeof</span>(struct sdshdr)+initlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存分配失败，返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置初始化长度</span></span><br><span class=\"line\">    sh-&gt;len = initlen;</span><br><span class=\"line\">    <span class=\"comment\">// 新 sds 不预留任何空间</span></span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initlen &amp;&amp; init)</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class=\"line\">    <span class=\"comment\">// 以 \\0 结尾</span></span><br><span class=\"line\">    sh-&gt;buf[initlen] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">char</span>*)sh-&gt;buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 zmalloc 和 zcalloc 为 redis 使用的内存管理工具，在 zmalloc.c 和 zmalloc.h 中定义</p>\n<h2 id=\"双端链表\"><a class=\"markdownIt-Anchor\" href=\"#双端链表\"></a> 双端链表</h2>\n<p>双端链表 的源码主要在 adlist.h 和 adlist.c 中</p>\n<p>双端链表节点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n<p>双端链表结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>为了规范化的宏定义函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回给定链表所包含的节点数量</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的表头节点</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的表尾节点</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定节点的前置节点</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定节点的后置节点</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定节点的值</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将链表 l 的值复制函数设置为 m</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class=\"line\"><span class=\"comment\">// 将链表 l 的值释放函数设置为 m</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class=\"line\"><span class=\"comment\">// 将链表的对比函数设置为 m</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的值复制函数</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的值释放函数</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的值对比函数</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure>\n<p>几个主要接口函数：</p>\n<ul>\n<li><strong>listCreate</strong><br />\n创建一个新的链表 T = O(1)</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listCreate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> *<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">list</span> = zmalloc(<span class=\"keyword\">sizeof</span>(*<span class=\"built_in\">list</span>))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化属性</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;dup = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;match = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listRelease</strong><br />\n释放整个链表，以及链表中所有节点</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRelease</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">    listNode *current, *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向头指针</span></span><br><span class=\"line\">    current = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历整个链表</span></span><br><span class=\"line\">    len = <span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(len--) &#123;</span><br><span class=\"line\">        next = current-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果有设置值释放函数，那么调用它</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(current-&gt;value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 释放节点结构</span></span><br><span class=\"line\">        zfree(current);</span><br><span class=\"line\"></span><br><span class=\"line\">        current = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放链表结构</span></span><br><span class=\"line\">    zfree(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listAddNodeHead</strong><br />\n将一个包含有给定值指针 value 的新节点添加到链表的表头</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listAddNodeHead</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为节点分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((node = zmalloc(<span class=\"keyword\">sizeof</span>(*node))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存值指针</span></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加节点到空链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">        node-&gt;prev = node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 添加节点到非空链表</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        node-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head-&gt;prev = node;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新链表节点数</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 redis 双端队列中使用了迭代器这一技巧</p>\n<p>双端链表迭代器：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listIter</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当前迭代到的节点</span></span><br><span class=\"line\">    listNode *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> direction;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listIter;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listGetIterator</strong><br />\n为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">listIter *<span class=\"title\">listGetIterator</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> direction)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为迭代器分配内存</span></span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((iter = zmalloc(<span class=\"keyword\">sizeof</span>(*iter))) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (direction == AL_START_HEAD)</span><br><span class=\"line\">        iter-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        iter-&gt;next = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录迭代方向</span></span><br><span class=\"line\">    iter-&gt;direction = direction;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> iter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listNext</strong><br />\n返回迭代器当前所指向的节点<br />\n这个函数其实有两个作用：返回当前迭代器指向的节点 + 使迭代器指向下一个节点（我刚开始还没明白只return了一个current，怎么把iter传出去，后来看了这个函数的使用才知道，因为函数传入的是指针，只要定义一个listIter类型的指针，一直使用该函数就能迭代了</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listNext</span><span class=\"params\">(listIter *iter)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *current = iter-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据方向选择下一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class=\"line\">            <span class=\"comment\">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class=\"line\">            iter-&gt;next = current-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class=\"line\">            iter-&gt;next = current-&gt;prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listDup</strong><br />\n复制整个链表<br />\n其中就使用了上述的listNext来进行迭代</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listDup</span><span class=\"params\">(<span class=\"built_in\">list</span> *orig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span> *copy;</span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建新链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((copy = listCreate()) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置节点值处理函数</span></span><br><span class=\"line\">    copy-&gt;dup = orig-&gt;dup;</span><br><span class=\"line\">    copy-&gt;<span class=\"built_in\">free</span> = orig-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">    copy-&gt;match = orig-&gt;match;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代整个输入链表</span></span><br><span class=\"line\">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((node = listNext(iter)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 复制节点值到新节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy-&gt;dup) &#123;</span><br><span class=\"line\">            value = copy-&gt;dup(node-&gt;value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                listRelease(copy);</span><br><span class=\"line\">                listReleaseIterator(iter);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            value = node-&gt;value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将节点添加到链表</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listAddNodeTail(copy, value) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            listRelease(copy);</span><br><span class=\"line\">            listReleaseIterator(iter);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放迭代器</span></span><br><span class=\"line\">    listReleaseIterator(iter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回副本</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#49B1F5","paginator":"#00C4B6","button_hover":"#FF7242","text_selection":"#00C4B6","link_color":"#858585","hr_color":"#A4D8FA","tag_start_color":"#A4D8FA","tag_end_color":"#1B9EF3","header_text_color":"#EEEEEE","footer_text_color":"#EEEEEE"},"menu":{"Home":"/","Tags":"/tags","Categories":"/categories"},"favicon":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/favicon.png","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"default","code_word_wrap":true,"social":{"github fa":"https://github.com/LittleMeepo"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":true,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"},"hide_scrollbar":true},"fireworks":false,"baidu_analytics":null,"google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/other/avatar.jpg","top_img":"https://cdn.jsdelivr.net/gh/littlemeepo/cdn@2.0/images/banner/0.jpg","top_img_height":80,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"league","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2019,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file\"></i>","page_pv_footer":null},"canvas_ribbon":{"enable":false,"size":150,"alpha":0.6,"zIndex":-1,"click_to_change":false},"follow":{"enable":false,"url":"","text":""},"sidebar_display":"post","google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true},"google_site_verification":null,"bing_site_verification":null,"baidu_site_verification":null,"qihu_site_verification":null,"disable_baidu_transformation":true,"404Text":null,"rootConfig":{"title":"Edith","subtitle":"Even dead, I'm the Hero.","description":"Wang's blog","author":"Wang","language":"zh-Hans","timezone":"","url":"https://wfc.ink","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"pretty_urls":{"trailing_index":true,"trailing_html":true},"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":{"enable":true,"field":"site","exclude":""},"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":"","wrap":true,"hljs":false},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","use_date_for_updated":false,"per_page":10,"pagination_dir":"page","theme":"melody","server":{"port":4000,"log":false,"compress":false,"header":true,"cache":false},"deploy":[{"type":"git","repo":"git@106.54.209.155:/home/git/blog.git","branch":"master"}],"ignore":null,"meta_generator":true,"keywords":["C++","Linux"],"index_generator":{"per_page":10,"order_by":"-date","path":""},"include":null,"exclude":null,"search":{"path":"search.xml","field":"post","content":true},"markdown_it_plus":{"plugins":[{"plugin":null,"name":"@neilsustc/markdown-it-katex","enable":true,"options":{"strict":false}}]},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10}}}}},"excerpt":"","more":"<h2 id=\"简单动态字符串sds\"><a class=\"markdownIt-Anchor\" href=\"#简单动态字符串sds\"></a> 简单动态字符串sds</h2>\n<p>sds 的源码主要在 sds.h 和 sds.c 中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 保存字符串对象的结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// buf 中已占用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf 中剩余可用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据空间</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其中 buf 数组是柔性数组，在分配的时候不占内存大小</p>\n<p>sds.h 中还有两个 inline 的静态函数，用于返回实际保存的字符串长度和可用空间的字符串长度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">sdslen</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span> <span class=\"comment\">//buf地址往回sizeof(struct sdshdr))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sh-&gt;len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回 sds 可用空间的长度</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">sdsavail</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sh-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这边用了一个骚操作，用 buf 的数组指针减去8字节，就得到了结构体的初始位置，也就是结构体的指针：</p>\n<div align='center'>\n  <img src=\"https://cdn.jsdelivr.net/gh/LittleMeepo/blog_images/images/redis/20200502162607.png\" height=\"180px\">\n</div>\n这个技巧在 redis 中多处用到\n<p>sds 主要接口函数声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 sds T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据给定字符串 init ，创建一个包含同样字符串的 sds T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并返回一个只保存了空字符串 \"\" 的 sds T = O(1)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsempty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回 sds 实际保存的字符串的长度 T = O(1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">sdslen</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制给定 sds 的副本 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsdup</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放给定的 sds T = O(N)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sdsfree</span><span class=\"params\">(sds s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回 sds 可用空间的长度 T = O(1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">sdsavail</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 sds 扩充至指定长度，未使用的空间以 0 字节填充 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsgrowzero</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatlen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *t, <span class=\"keyword\">size_t</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将给定字符串 t 追加到 sds 的末尾 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscat</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将另一个 sds 追加到一个 sds 的末尾 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatsds</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> sds t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将字符串 t 的前 len 个字符复制到 sds s 当中，并在字符串的最后添加终结符 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscpylen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t, <span class=\"keyword\">size_t</span> len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将字符串复制到 sds 当中，覆盖原有的字符 T = O(N)</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscpy</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>其中几个：</p>\n<ul>\n<li><strong>sdsnew</strong><br />\n根据给定字符串 init ，创建一个包含同样字符串的 sds</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> initlen = (init == <span class=\"literal\">NULL</span>) ? <span class=\"number\">0</span> : <span class=\"built_in\">strlen</span>(init);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(init, initlen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中调用了：</p>\n<ul>\n<li><strong>sdsnewlen</strong><br />\n根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (init) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// zmalloc 不初始化所分配的内存</span></span><br><span class=\"line\">        sh = zmalloc(<span class=\"keyword\">sizeof</span>(struct sdshdr)+initlen+<span class=\"number\">1</span>); <span class=\"comment\">// 结构体+buf数组+'\\0'</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class=\"line\">        sh = zcalloc(<span class=\"keyword\">sizeof</span>(struct sdshdr)+initlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存分配失败，返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置初始化长度</span></span><br><span class=\"line\">    sh-&gt;len = initlen;</span><br><span class=\"line\">    <span class=\"comment\">// 新 sds 不预留任何空间</span></span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initlen &amp;&amp; init)</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class=\"line\">    <span class=\"comment\">// 以 \\0 结尾</span></span><br><span class=\"line\">    sh-&gt;buf[initlen] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">char</span>*)sh-&gt;buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 zmalloc 和 zcalloc 为 redis 使用的内存管理工具，在 zmalloc.c 和 zmalloc.h 中定义</p>\n<h2 id=\"双端链表\"><a class=\"markdownIt-Anchor\" href=\"#双端链表\"></a> 双端链表</h2>\n<p>双端链表 的源码主要在 adlist.h 和 adlist.c 中</p>\n<p>双端链表节点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n<p>双端链表结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>为了规范化的宏定义函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回给定链表所包含的节点数量</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的表头节点</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的表尾节点</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定节点的前置节点</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定节点的后置节点</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定节点的值</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将链表 l 的值复制函数设置为 m</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class=\"line\"><span class=\"comment\">// 将链表 l 的值释放函数设置为 m</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class=\"line\"><span class=\"comment\">// 将链表的对比函数设置为 m</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的值复制函数</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的值释放函数</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class=\"line\"><span class=\"comment\">// 返回给定链表的值对比函数</span></span><br><span class=\"line\"><span class=\"comment\">// T = O(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure>\n<p>几个主要接口函数：</p>\n<ul>\n<li><strong>listCreate</strong><br />\n创建一个新的链表 T = O(1)</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listCreate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> *<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">list</span> = zmalloc(<span class=\"keyword\">sizeof</span>(*<span class=\"built_in\">list</span>))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化属性</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;dup = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;match = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listRelease</strong><br />\n释放整个链表，以及链表中所有节点</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRelease</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">    listNode *current, *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向头指针</span></span><br><span class=\"line\">    current = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历整个链表</span></span><br><span class=\"line\">    len = <span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(len--) &#123;</span><br><span class=\"line\">        next = current-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果有设置值释放函数，那么调用它</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(current-&gt;value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 释放节点结构</span></span><br><span class=\"line\">        zfree(current);</span><br><span class=\"line\"></span><br><span class=\"line\">        current = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放链表结构</span></span><br><span class=\"line\">    zfree(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listAddNodeHead</strong><br />\n将一个包含有给定值指针 value 的新节点添加到链表的表头</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listAddNodeHead</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为节点分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((node = zmalloc(<span class=\"keyword\">sizeof</span>(*node))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存值指针</span></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加节点到空链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">        node-&gt;prev = node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 添加节点到非空链表</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        node-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head-&gt;prev = node;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新链表节点数</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 redis 双端队列中使用了迭代器这一技巧</p>\n<p>双端链表迭代器：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listIter</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当前迭代到的节点</span></span><br><span class=\"line\">    listNode *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> direction;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listIter;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listGetIterator</strong><br />\n为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">listIter *<span class=\"title\">listGetIterator</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> direction)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为迭代器分配内存</span></span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((iter = zmalloc(<span class=\"keyword\">sizeof</span>(*iter))) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (direction == AL_START_HEAD)</span><br><span class=\"line\">        iter-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        iter-&gt;next = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录迭代方向</span></span><br><span class=\"line\">    iter-&gt;direction = direction;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> iter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listNext</strong><br />\n返回迭代器当前所指向的节点<br />\n这个函数其实有两个作用：返回当前迭代器指向的节点 + 使迭代器指向下一个节点（我刚开始还没明白只return了一个current，怎么把iter传出去，后来看了这个函数的使用才知道，因为函数传入的是指针，只要定义一个listIter类型的指针，一直使用该函数就能迭代了</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listNext</span><span class=\"params\">(listIter *iter)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *current = iter-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据方向选择下一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class=\"line\">            <span class=\"comment\">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class=\"line\">            iter-&gt;next = current-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class=\"line\">            iter-&gt;next = current-&gt;prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>listDup</strong><br />\n复制整个链表<br />\n其中就使用了上述的listNext来进行迭代</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listDup</span><span class=\"params\">(<span class=\"built_in\">list</span> *orig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span> *copy;</span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建新链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((copy = listCreate()) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置节点值处理函数</span></span><br><span class=\"line\">    copy-&gt;dup = orig-&gt;dup;</span><br><span class=\"line\">    copy-&gt;<span class=\"built_in\">free</span> = orig-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">    copy-&gt;match = orig-&gt;match;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代整个输入链表</span></span><br><span class=\"line\">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((node = listNext(iter)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 复制节点值到新节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy-&gt;dup) &#123;</span><br><span class=\"line\">            value = copy-&gt;dup(node-&gt;value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                listRelease(copy);</span><br><span class=\"line\">                listReleaseIterator(iter);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            value = node-&gt;value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将节点添加到链表</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listAddNodeTail(copy, value) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            listRelease(copy);</span><br><span class=\"line\">            listReleaseIterator(iter);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放迭代器</span></span><br><span class=\"line\">    listReleaseIterator(iter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回副本</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckfi6k1ao0001z4wj45sp2fov","category_id":"ckfi6k1aw0002z4wjdu6bdjmu","_id":"ckfi6k1b10005z4wje0mn0dhn"}],"PostTag":[{"post_id":"ckfi6k1ao0001z4wj45sp2fov","tag_id":"ckfi6k1ay0003z4wjabl6ggmu","_id":"ckfi6k1b10004z4wjeqa76roo"}],"Tag":[{"name":"redis","_id":"ckfi6k1ay0003z4wjabl6ggmu"}]}}